// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "mls_validation/v1/service.proto" (package "xmtp.mls_validation.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Contains a batch of serialized Key Packages
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesRequest
 */
export interface ValidateKeyPackagesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.mls_validation.v1.ValidateKeyPackagesRequest.KeyPackage key_packages = 1;
     */
    keyPackages: ValidateKeyPackagesRequest_KeyPackage[];
}
/**
 * Wrapper for each key package
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesRequest.KeyPackage
 */
export interface ValidateKeyPackagesRequest_KeyPackage {
    /**
     * @generated from protobuf field: bytes key_package_bytes_tls_serialized = 1;
     */
    keyPackageBytesTlsSerialized: Uint8Array;
}
/**
 * Response to ValidateKeyPackagesRequest
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesResponse
 */
export interface ValidateKeyPackagesResponse {
    /**
     * @generated from protobuf field: repeated xmtp.mls_validation.v1.ValidateKeyPackagesResponse.ValidationResponse responses = 1;
     */
    responses: ValidateKeyPackagesResponse_ValidationResponse[];
}
/**
 * An individual response to one key package
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesResponse.ValidationResponse
 */
export interface ValidateKeyPackagesResponse_ValidationResponse {
    /**
     * @generated from protobuf field: bool is_ok = 1;
     */
    isOk: boolean;
    /**
     * @generated from protobuf field: string error_message = 2;
     */
    errorMessage: string;
    /**
     * @generated from protobuf field: bytes installation_id = 3;
     */
    installationId: Uint8Array;
    /**
     * @generated from protobuf field: string account_address = 4;
     */
    accountAddress: string;
    /**
     * @generated from protobuf field: bytes credential_identity_bytes = 5;
     */
    credentialIdentityBytes: Uint8Array;
    /**
     * @generated from protobuf field: uint64 expiration = 6;
     */
    expiration: bigint;
}
/**
 * Contains a batch of serialized Group Messages
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesRequest
 */
export interface ValidateGroupMessagesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.mls_validation.v1.ValidateGroupMessagesRequest.GroupMessage group_messages = 1;
     */
    groupMessages: ValidateGroupMessagesRequest_GroupMessage[];
}
/**
 * Wrapper for each message
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesRequest.GroupMessage
 */
export interface ValidateGroupMessagesRequest_GroupMessage {
    /**
     * @generated from protobuf field: bytes group_message_bytes_tls_serialized = 1;
     */
    groupMessageBytesTlsSerialized: Uint8Array;
}
/**
 * Response to ValidateGroupMessagesRequest
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesResponse
 */
export interface ValidateGroupMessagesResponse {
    /**
     * @generated from protobuf field: repeated xmtp.mls_validation.v1.ValidateGroupMessagesResponse.ValidationResponse responses = 1;
     */
    responses: ValidateGroupMessagesResponse_ValidationResponse[];
}
/**
 * An individual response to one message
 *
 * @generated from protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesResponse.ValidationResponse
 */
export interface ValidateGroupMessagesResponse_ValidationResponse {
    /**
     * @generated from protobuf field: bool is_ok = 1;
     */
    isOk: boolean;
    /**
     * @generated from protobuf field: string error_message = 2;
     */
    errorMessage: string;
    /**
     * @generated from protobuf field: string group_id = 3;
     */
    groupId: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyPackagesRequest$Type extends MessageType<ValidateKeyPackagesRequest> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateKeyPackagesRequest", [
            { no: 1, name: "key_packages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidateKeyPackagesRequest_KeyPackage }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyPackagesRequest>): ValidateKeyPackagesRequest {
        const message = { keyPackages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyPackagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyPackagesRequest): ValidateKeyPackagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls_validation.v1.ValidateKeyPackagesRequest.KeyPackage key_packages */ 1:
                    message.keyPackages.push(ValidateKeyPackagesRequest_KeyPackage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateKeyPackagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls_validation.v1.ValidateKeyPackagesRequest.KeyPackage key_packages = 1; */
        for (let i = 0; i < message.keyPackages.length; i++)
            ValidateKeyPackagesRequest_KeyPackage.internalBinaryWrite(message.keyPackages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesRequest
 */
export const ValidateKeyPackagesRequest = new ValidateKeyPackagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyPackagesRequest_KeyPackage$Type extends MessageType<ValidateKeyPackagesRequest_KeyPackage> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateKeyPackagesRequest.KeyPackage", [
            { no: 1, name: "key_package_bytes_tls_serialized", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyPackagesRequest_KeyPackage>): ValidateKeyPackagesRequest_KeyPackage {
        const message = { keyPackageBytesTlsSerialized: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyPackagesRequest_KeyPackage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyPackagesRequest_KeyPackage): ValidateKeyPackagesRequest_KeyPackage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key_package_bytes_tls_serialized */ 1:
                    message.keyPackageBytesTlsSerialized = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateKeyPackagesRequest_KeyPackage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key_package_bytes_tls_serialized = 1; */
        if (message.keyPackageBytesTlsSerialized.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyPackageBytesTlsSerialized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesRequest.KeyPackage
 */
export const ValidateKeyPackagesRequest_KeyPackage = new ValidateKeyPackagesRequest_KeyPackage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyPackagesResponse$Type extends MessageType<ValidateKeyPackagesResponse> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateKeyPackagesResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidateKeyPackagesResponse_ValidationResponse }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyPackagesResponse>): ValidateKeyPackagesResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyPackagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyPackagesResponse): ValidateKeyPackagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls_validation.v1.ValidateKeyPackagesResponse.ValidationResponse responses */ 1:
                    message.responses.push(ValidateKeyPackagesResponse_ValidationResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateKeyPackagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls_validation.v1.ValidateKeyPackagesResponse.ValidationResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            ValidateKeyPackagesResponse_ValidationResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesResponse
 */
export const ValidateKeyPackagesResponse = new ValidateKeyPackagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateKeyPackagesResponse_ValidationResponse$Type extends MessageType<ValidateKeyPackagesResponse_ValidationResponse> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateKeyPackagesResponse.ValidationResponse", [
            { no: 1, name: "is_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "installation_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "account_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "credential_identity_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "expiration", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateKeyPackagesResponse_ValidationResponse>): ValidateKeyPackagesResponse_ValidationResponse {
        const message = { isOk: false, errorMessage: "", installationId: new Uint8Array(0), accountAddress: "", credentialIdentityBytes: new Uint8Array(0), expiration: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateKeyPackagesResponse_ValidationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateKeyPackagesResponse_ValidationResponse): ValidateKeyPackagesResponse_ValidationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_ok */ 1:
                    message.isOk = reader.bool();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                case /* bytes installation_id */ 3:
                    message.installationId = reader.bytes();
                    break;
                case /* string account_address */ 4:
                    message.accountAddress = reader.string();
                    break;
                case /* bytes credential_identity_bytes */ 5:
                    message.credentialIdentityBytes = reader.bytes();
                    break;
                case /* uint64 expiration */ 6:
                    message.expiration = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateKeyPackagesResponse_ValidationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_ok = 1; */
        if (message.isOk !== false)
            writer.tag(1, WireType.Varint).bool(message.isOk);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        /* bytes installation_id = 3; */
        if (message.installationId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.installationId);
        /* string account_address = 4; */
        if (message.accountAddress !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.accountAddress);
        /* bytes credential_identity_bytes = 5; */
        if (message.credentialIdentityBytes.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.credentialIdentityBytes);
        /* uint64 expiration = 6; */
        if (message.expiration !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.expiration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateKeyPackagesResponse.ValidationResponse
 */
export const ValidateKeyPackagesResponse_ValidationResponse = new ValidateKeyPackagesResponse_ValidationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateGroupMessagesRequest$Type extends MessageType<ValidateGroupMessagesRequest> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateGroupMessagesRequest", [
            { no: 1, name: "group_messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidateGroupMessagesRequest_GroupMessage }
        ]);
    }
    create(value?: PartialMessage<ValidateGroupMessagesRequest>): ValidateGroupMessagesRequest {
        const message = { groupMessages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateGroupMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateGroupMessagesRequest): ValidateGroupMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls_validation.v1.ValidateGroupMessagesRequest.GroupMessage group_messages */ 1:
                    message.groupMessages.push(ValidateGroupMessagesRequest_GroupMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateGroupMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls_validation.v1.ValidateGroupMessagesRequest.GroupMessage group_messages = 1; */
        for (let i = 0; i < message.groupMessages.length; i++)
            ValidateGroupMessagesRequest_GroupMessage.internalBinaryWrite(message.groupMessages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesRequest
 */
export const ValidateGroupMessagesRequest = new ValidateGroupMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateGroupMessagesRequest_GroupMessage$Type extends MessageType<ValidateGroupMessagesRequest_GroupMessage> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateGroupMessagesRequest.GroupMessage", [
            { no: 1, name: "group_message_bytes_tls_serialized", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateGroupMessagesRequest_GroupMessage>): ValidateGroupMessagesRequest_GroupMessage {
        const message = { groupMessageBytesTlsSerialized: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateGroupMessagesRequest_GroupMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateGroupMessagesRequest_GroupMessage): ValidateGroupMessagesRequest_GroupMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes group_message_bytes_tls_serialized */ 1:
                    message.groupMessageBytesTlsSerialized = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateGroupMessagesRequest_GroupMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes group_message_bytes_tls_serialized = 1; */
        if (message.groupMessageBytesTlsSerialized.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.groupMessageBytesTlsSerialized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesRequest.GroupMessage
 */
export const ValidateGroupMessagesRequest_GroupMessage = new ValidateGroupMessagesRequest_GroupMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateGroupMessagesResponse$Type extends MessageType<ValidateGroupMessagesResponse> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateGroupMessagesResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ValidateGroupMessagesResponse_ValidationResponse }
        ]);
    }
    create(value?: PartialMessage<ValidateGroupMessagesResponse>): ValidateGroupMessagesResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateGroupMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateGroupMessagesResponse): ValidateGroupMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls_validation.v1.ValidateGroupMessagesResponse.ValidationResponse responses */ 1:
                    message.responses.push(ValidateGroupMessagesResponse_ValidationResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateGroupMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls_validation.v1.ValidateGroupMessagesResponse.ValidationResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            ValidateGroupMessagesResponse_ValidationResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesResponse
 */
export const ValidateGroupMessagesResponse = new ValidateGroupMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ValidateGroupMessagesResponse_ValidationResponse$Type extends MessageType<ValidateGroupMessagesResponse_ValidationResponse> {
    constructor() {
        super("xmtp.mls_validation.v1.ValidateGroupMessagesResponse.ValidationResponse", [
            { no: 1, name: "is_ok", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "group_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ValidateGroupMessagesResponse_ValidationResponse>): ValidateGroupMessagesResponse_ValidationResponse {
        const message = { isOk: false, errorMessage: "", groupId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ValidateGroupMessagesResponse_ValidationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ValidateGroupMessagesResponse_ValidationResponse): ValidateGroupMessagesResponse_ValidationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool is_ok */ 1:
                    message.isOk = reader.bool();
                    break;
                case /* string error_message */ 2:
                    message.errorMessage = reader.string();
                    break;
                case /* string group_id */ 3:
                    message.groupId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ValidateGroupMessagesResponse_ValidationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool is_ok = 1; */
        if (message.isOk !== false)
            writer.tag(1, WireType.Varint).bool(message.isOk);
        /* string error_message = 2; */
        if (message.errorMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.errorMessage);
        /* string group_id = 3; */
        if (message.groupId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.groupId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls_validation.v1.ValidateGroupMessagesResponse.ValidationResponse
 */
export const ValidateGroupMessagesResponse_ValidationResponse = new ValidateGroupMessagesResponse_ValidationResponse$Type();
/**
 * @generated ServiceType for protobuf service xmtp.mls_validation.v1.ValidationApi
 */
export const ValidationApi = new ServiceType("xmtp.mls_validation.v1.ValidationApi", [
    { name: "ValidateKeyPackages", options: {}, I: ValidateKeyPackagesRequest, O: ValidateKeyPackagesResponse },
    { name: "ValidateGroupMessages", options: {}, I: ValidateGroupMessagesRequest, O: ValidateGroupMessagesResponse }
]);
