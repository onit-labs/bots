// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "message_api/v1/message_api.proto" (package "xmtp.message_api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * This is based off of the go-waku Index type, but with the
 * receiverTime and pubsubTopic removed for simplicity.
 * Both removed fields are optional
 *
 * @generated from protobuf message xmtp.message_api.v1.IndexCursor
 */
export interface IndexCursor {
    /**
     * @generated from protobuf field: bytes digest = 1;
     */
    digest: Uint8Array;
    /**
     * @generated from protobuf field: uint64 sender_time_ns = 2;
     */
    senderTimeNs: bigint;
}
/**
 * Wrapper for potentially multiple types of cursor
 *
 * @generated from protobuf message xmtp.message_api.v1.Cursor
 */
export interface Cursor {
    /**
     * @generated from protobuf oneof: cursor
     */
    cursor: {
        oneofKind: "index";
        /**
         * @generated from protobuf field: xmtp.message_api.v1.IndexCursor index = 1;
         */
        index: IndexCursor;
    } | {
        oneofKind: undefined;
    };
}
/**
 * This is based off of the go-waku PagingInfo struct, but with the direction
 * changed to our SortDirection enum format
 *
 * @generated from protobuf message xmtp.message_api.v1.PagingInfo
 */
export interface PagingInfo {
    /**
     * Note: this is a uint32, while go-waku's pageSize is a uint64
     *
     * @generated from protobuf field: uint32 limit = 1;
     */
    limit: number;
    /**
     * @generated from protobuf field: xmtp.message_api.v1.Cursor cursor = 2;
     */
    cursor?: Cursor;
    /**
     * @generated from protobuf field: xmtp.message_api.v1.SortDirection direction = 3;
     */
    direction: SortDirection;
}
/**
 * Envelope encapsulates a message while in transit.
 *
 * @generated from protobuf message xmtp.message_api.v1.Envelope
 */
export interface Envelope {
    /**
     * The topic the message belongs to,
     * If the message includes the topic as well
     * it MUST be the same as the topic in the envelope.
     *
     * @generated from protobuf field: string content_topic = 1;
     */
    contentTopic: string;
    /**
     * Message creation timestamp
     * If the message includes the timestamp as well
     * it MUST be equivalent to the timestamp in the envelope.
     *
     * @generated from protobuf field: uint64 timestamp_ns = 2;
     */
    timestampNs: bigint;
    /**
     * @generated from protobuf field: bytes message = 3;
     */
    message: Uint8Array;
}
/**
 * Publish
 *
 * @generated from protobuf message xmtp.message_api.v1.PublishRequest
 */
export interface PublishRequest {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.Envelope envelopes = 1;
     */
    envelopes: Envelope[];
}
/**
 * Empty message as a response for Publish
 *
 * @generated from protobuf message xmtp.message_api.v1.PublishResponse
 */
export interface PublishResponse {
}
/**
 * Subscribe
 *
 * @generated from protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export interface SubscribeRequest {
    /**
     * @generated from protobuf field: repeated string content_topics = 1;
     */
    contentTopics: string[];
}
/**
 * SubscribeAll
 *
 * @generated from protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export interface SubscribeAllRequest {
}
/**
 * Query
 *
 * @generated from protobuf message xmtp.message_api.v1.QueryRequest
 */
export interface QueryRequest {
    /**
     * @generated from protobuf field: repeated string content_topics = 1;
     */
    contentTopics: string[];
    /**
     * @generated from protobuf field: uint64 start_time_ns = 2;
     */
    startTimeNs: bigint;
    /**
     * @generated from protobuf field: uint64 end_time_ns = 3;
     */
    endTimeNs: bigint;
    /**
     * @generated from protobuf field: xmtp.message_api.v1.PagingInfo paging_info = 4;
     */
    pagingInfo?: PagingInfo;
}
/**
 * The response, containing envelopes, for a query
 *
 * @generated from protobuf message xmtp.message_api.v1.QueryResponse
 */
export interface QueryResponse {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.Envelope envelopes = 1;
     */
    envelopes: Envelope[];
    /**
     * @generated from protobuf field: xmtp.message_api.v1.PagingInfo paging_info = 2;
     */
    pagingInfo?: PagingInfo;
}
/**
 * BatchQuery
 *
 * @generated from protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export interface BatchQueryRequest {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.QueryRequest requests = 1;
     */
    requests: QueryRequest[];
}
/**
 * Response containing a list of QueryResponse messages
 *
 * @generated from protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export interface BatchQueryResponse {
    /**
     * @generated from protobuf field: repeated xmtp.message_api.v1.QueryResponse responses = 1;
     */
    responses: QueryResponse[];
}
/**
 * Sort direction
 *
 * @generated from protobuf enum xmtp.message_api.v1.SortDirection
 */
export enum SortDirection {
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_ASCENDING = 1;
     */
    ASCENDING = 1,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_DESCENDING = 2;
     */
    DESCENDING = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class IndexCursor$Type extends MessageType<IndexCursor> {
    constructor() {
        super("xmtp.message_api.v1.IndexCursor", [
            { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sender_time_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<IndexCursor>): IndexCursor {
        const message = { digest: new Uint8Array(0), senderTimeNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndexCursor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndexCursor): IndexCursor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes digest */ 1:
                    message.digest = reader.bytes();
                    break;
                case /* uint64 sender_time_ns */ 2:
                    message.senderTimeNs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndexCursor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes digest = 1; */
        if (message.digest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.digest);
        /* uint64 sender_time_ns = 2; */
        if (message.senderTimeNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.senderTimeNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.IndexCursor
 */
export const IndexCursor = new IndexCursor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cursor$Type extends MessageType<Cursor> {
    constructor() {
        super("xmtp.message_api.v1.Cursor", [
            { no: 1, name: "index", kind: "message", oneof: "cursor", T: () => IndexCursor }
        ]);
    }
    create(value?: PartialMessage<Cursor>): Cursor {
        const message = { cursor: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Cursor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cursor): Cursor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_api.v1.IndexCursor index */ 1:
                    message.cursor = {
                        oneofKind: "index",
                        index: IndexCursor.internalBinaryRead(reader, reader.uint32(), options, (message.cursor as any).index)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cursor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_api.v1.IndexCursor index = 1; */
        if (message.cursor.oneofKind === "index")
            IndexCursor.internalBinaryWrite(message.cursor.index, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Cursor
 */
export const Cursor = new Cursor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PagingInfo$Type extends MessageType<PagingInfo> {
    constructor() {
        super("xmtp.message_api.v1.PagingInfo", [
            { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "cursor", kind: "message", T: () => Cursor },
            { no: 3, name: "direction", kind: "enum", T: () => ["xmtp.message_api.v1.SortDirection", SortDirection, "SORT_DIRECTION_"] }
        ]);
    }
    create(value?: PartialMessage<PagingInfo>): PagingInfo {
        const message = { limit: 0, direction: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PagingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PagingInfo): PagingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 limit */ 1:
                    message.limit = reader.uint32();
                    break;
                case /* xmtp.message_api.v1.Cursor cursor */ 2:
                    message.cursor = Cursor.internalBinaryRead(reader, reader.uint32(), options, message.cursor);
                    break;
                case /* xmtp.message_api.v1.SortDirection direction */ 3:
                    message.direction = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PagingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 limit = 1; */
        if (message.limit !== 0)
            writer.tag(1, WireType.Varint).uint32(message.limit);
        /* xmtp.message_api.v1.Cursor cursor = 2; */
        if (message.cursor)
            Cursor.internalBinaryWrite(message.cursor, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_api.v1.SortDirection direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PagingInfo
 */
export const PagingInfo = new PagingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Envelope$Type extends MessageType<Envelope> {
    constructor() {
        super("xmtp.message_api.v1.Envelope", [
            { no: 1, name: "content_topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Envelope>): Envelope {
        const message = { contentTopic: "", timestampNs: 0n, message: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Envelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Envelope): Envelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content_topic */ 1:
                    message.contentTopic = reader.string();
                    break;
                case /* uint64 timestamp_ns */ 2:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                case /* bytes message */ 3:
                    message.message = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Envelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content_topic = 1; */
        if (message.contentTopic !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopic);
        /* uint64 timestamp_ns = 2; */
        if (message.timestampNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestampNs);
        /* bytes message = 3; */
        if (message.message.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Envelope
 */
export const Envelope = new Envelope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishRequest$Type extends MessageType<PublishRequest> {
    constructor() {
        super("xmtp.message_api.v1.PublishRequest", [
            { no: 1, name: "envelopes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Envelope }
        ]);
    }
    create(value?: PartialMessage<PublishRequest>): PublishRequest {
        const message = { envelopes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PublishRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishRequest): PublishRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.Envelope envelopes */ 1:
                    message.envelopes.push(Envelope.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublishRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.message_api.v1.Envelope envelopes = 1; */
        for (let i = 0; i < message.envelopes.length; i++)
            Envelope.internalBinaryWrite(message.envelopes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishRequest
 */
export const PublishRequest = new PublishRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublishResponse$Type extends MessageType<PublishResponse> {
    constructor() {
        super("xmtp.message_api.v1.PublishResponse", []);
    }
    create(value?: PartialMessage<PublishResponse>): PublishResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PublishResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublishResponse): PublishResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PublishResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishResponse
 */
export const PublishResponse = new PublishResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequest$Type extends MessageType<SubscribeRequest> {
    constructor() {
        super("xmtp.message_api.v1.SubscribeRequest", [
            { no: 1, name: "content_topics", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeRequest>): SubscribeRequest {
        const message = { contentTopics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeRequest): SubscribeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string content_topics */ 1:
                    message.contentTopics.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string content_topics = 1; */
        for (let i = 0; i < message.contentTopics.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopics[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export const SubscribeRequest = new SubscribeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAllRequest$Type extends MessageType<SubscribeAllRequest> {
    constructor() {
        super("xmtp.message_api.v1.SubscribeAllRequest", []);
    }
    create(value?: PartialMessage<SubscribeAllRequest>): SubscribeAllRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeAllRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeAllRequest): SubscribeAllRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SubscribeAllRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export const SubscribeAllRequest = new SubscribeAllRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
    constructor() {
        super("xmtp.message_api.v1.QueryRequest", [
            { no: 1, name: "content_topics", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "start_time_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "end_time_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "paging_info", kind: "message", T: () => PagingInfo }
        ]);
    }
    create(value?: PartialMessage<QueryRequest>): QueryRequest {
        const message = { contentTopics: [], startTimeNs: 0n, endTimeNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryRequest): QueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string content_topics */ 1:
                    message.contentTopics.push(reader.string());
                    break;
                case /* uint64 start_time_ns */ 2:
                    message.startTimeNs = reader.uint64().toBigInt();
                    break;
                case /* uint64 end_time_ns */ 3:
                    message.endTimeNs = reader.uint64().toBigInt();
                    break;
                case /* xmtp.message_api.v1.PagingInfo paging_info */ 4:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string content_topics = 1; */
        for (let i = 0; i < message.contentTopics.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopics[i]);
        /* uint64 start_time_ns = 2; */
        if (message.startTimeNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.startTimeNs);
        /* uint64 end_time_ns = 3; */
        if (message.endTimeNs !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.endTimeNs);
        /* xmtp.message_api.v1.PagingInfo paging_info = 4; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
    constructor() {
        super("xmtp.message_api.v1.QueryResponse", [
            { no: 1, name: "envelopes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Envelope },
            { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo }
        ]);
    }
    create(value?: PartialMessage<QueryResponse>): QueryResponse {
        const message = { envelopes: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryResponse): QueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.Envelope envelopes */ 1:
                    message.envelopes.push(Envelope.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* xmtp.message_api.v1.PagingInfo paging_info */ 2:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.message_api.v1.Envelope envelopes = 1; */
        for (let i = 0; i < message.envelopes.length; i++)
            Envelope.internalBinaryWrite(message.envelopes[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_api.v1.PagingInfo paging_info = 2; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchQueryRequest$Type extends MessageType<BatchQueryRequest> {
    constructor() {
        super("xmtp.message_api.v1.BatchQueryRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryRequest }
        ]);
    }
    create(value?: PartialMessage<BatchQueryRequest>): BatchQueryRequest {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchQueryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchQueryRequest): BatchQueryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.QueryRequest requests */ 1:
                    message.requests.push(QueryRequest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchQueryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.message_api.v1.QueryRequest requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            QueryRequest.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export const BatchQueryRequest = new BatchQueryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BatchQueryResponse$Type extends MessageType<BatchQueryResponse> {
    constructor() {
        super("xmtp.message_api.v1.BatchQueryResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => QueryResponse }
        ]);
    }
    create(value?: PartialMessage<BatchQueryResponse>): BatchQueryResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BatchQueryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BatchQueryResponse): BatchQueryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_api.v1.QueryResponse responses */ 1:
                    message.responses.push(QueryResponse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BatchQueryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.message_api.v1.QueryResponse responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            QueryResponse.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export const BatchQueryResponse = new BatchQueryResponse$Type();
/**
 * @generated ServiceType for protobuf service xmtp.message_api.v1.MessageApi
 */
export const MessageApi = new ServiceType("xmtp.message_api.v1.MessageApi", [
    { name: "Publish", options: { "google.api.http": { post: "/message/v1/publish", body: "*" } }, I: PublishRequest, O: PublishResponse },
    { name: "Subscribe", serverStreaming: true, options: { "google.api.http": { post: "/message/v1/subscribe", body: "*" } }, I: SubscribeRequest, O: Envelope },
    { name: "Subscribe2", serverStreaming: true, clientStreaming: true, options: {}, I: SubscribeRequest, O: Envelope },
    { name: "SubscribeAll", serverStreaming: true, options: { "google.api.http": { post: "/message/v1/subscribe-all", body: "*" } }, I: SubscribeAllRequest, O: Envelope },
    { name: "Query", options: { "google.api.http": { post: "/message/v1/query", body: "*" } }, I: QueryRequest, O: QueryResponse },
    { name: "BatchQuery", options: { "google.api.http": { post: "/message/v1/batch-query", body: "*" } }, I: BatchQueryRequest, O: BatchQueryResponse }
]);
