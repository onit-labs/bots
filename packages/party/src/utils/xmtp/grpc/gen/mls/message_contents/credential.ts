// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "mls/message_contents/credential.proto" (package "xmtp.mls.message_contents", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { RevokeMessagingAccessAssociation } from "./association";
import { LegacyCreateIdentityAssociation } from "./association";
import { GrantMessagingAccessAssociation } from "./association";
/**
 * A credential that can be used in MLS leaf nodes
 *
 * @generated from protobuf message xmtp.mls.message_contents.MlsCredential
 */
export interface MlsCredential {
    /**
     * @generated from protobuf field: bytes installation_public_key = 1;
     */
    installationPublicKey: Uint8Array;
    /**
     * @generated from protobuf oneof: association
     */
    association: {
        oneofKind: "messagingAccess";
        /**
         * @generated from protobuf field: xmtp.mls.message_contents.GrantMessagingAccessAssociation messaging_access = 2;
         */
        messagingAccess: GrantMessagingAccessAssociation;
    } | {
        oneofKind: "legacyCreateIdentity";
        /**
         * @generated from protobuf field: xmtp.mls.message_contents.LegacyCreateIdentityAssociation legacy_create_identity = 3;
         */
        legacyCreateIdentity: LegacyCreateIdentityAssociation;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A declaration and proof that a credential is no longer valid
 *
 * @generated from protobuf message xmtp.mls.message_contents.CredentialRevocation
 */
export interface CredentialRevocation {
    /**
     * @generated from protobuf oneof: public_key
     */
    publicKey: {
        oneofKind: "installationKey";
        /**
         * The 'installation_public_key' field of the MlsCredential proto
         *
         * @generated from protobuf field: bytes installation_key = 1;
         */
        installationKey: Uint8Array;
    } | {
        oneofKind: "unsignedLegacyCreateIdentityKey";
        /**
         * The 'key_bytes' field of the legacy SignedPublicKey proto
         *
         * @generated from protobuf field: bytes unsigned_legacy_create_identity_key = 2;
         */
        unsignedLegacyCreateIdentityKey: Uint8Array;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: association
     */
    association: {
        oneofKind: "messagingAccess";
        /**
         * @generated from protobuf field: xmtp.mls.message_contents.RevokeMessagingAccessAssociation messaging_access = 3;
         */
        messagingAccess: RevokeMessagingAccessAssociation;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class MlsCredential$Type extends MessageType<MlsCredential> {
    constructor() {
        super("xmtp.mls.message_contents.MlsCredential", [
            { no: 1, name: "installation_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "messaging_access", kind: "message", oneof: "association", T: () => GrantMessagingAccessAssociation },
            { no: 3, name: "legacy_create_identity", kind: "message", oneof: "association", T: () => LegacyCreateIdentityAssociation }
        ]);
    }
    create(value?: PartialMessage<MlsCredential>): MlsCredential {
        const message = { installationPublicKey: new Uint8Array(0), association: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MlsCredential>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MlsCredential): MlsCredential {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_public_key */ 1:
                    message.installationPublicKey = reader.bytes();
                    break;
                case /* xmtp.mls.message_contents.GrantMessagingAccessAssociation messaging_access */ 2:
                    message.association = {
                        oneofKind: "messagingAccess",
                        messagingAccess: GrantMessagingAccessAssociation.internalBinaryRead(reader, reader.uint32(), options, (message.association as any).messagingAccess)
                    };
                    break;
                case /* xmtp.mls.message_contents.LegacyCreateIdentityAssociation legacy_create_identity */ 3:
                    message.association = {
                        oneofKind: "legacyCreateIdentity",
                        legacyCreateIdentity: LegacyCreateIdentityAssociation.internalBinaryRead(reader, reader.uint32(), options, (message.association as any).legacyCreateIdentity)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MlsCredential, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_public_key = 1; */
        if (message.installationPublicKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationPublicKey);
        /* xmtp.mls.message_contents.GrantMessagingAccessAssociation messaging_access = 2; */
        if (message.association.oneofKind === "messagingAccess")
            GrantMessagingAccessAssociation.internalBinaryWrite(message.association.messagingAccess, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.mls.message_contents.LegacyCreateIdentityAssociation legacy_create_identity = 3; */
        if (message.association.oneofKind === "legacyCreateIdentity")
            LegacyCreateIdentityAssociation.internalBinaryWrite(message.association.legacyCreateIdentity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.MlsCredential
 */
export const MlsCredential = new MlsCredential$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CredentialRevocation$Type extends MessageType<CredentialRevocation> {
    constructor() {
        super("xmtp.mls.message_contents.CredentialRevocation", [
            { no: 1, name: "installation_key", kind: "scalar", oneof: "publicKey", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "unsigned_legacy_create_identity_key", kind: "scalar", oneof: "publicKey", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "messaging_access", kind: "message", oneof: "association", T: () => RevokeMessagingAccessAssociation }
        ]);
    }
    create(value?: PartialMessage<CredentialRevocation>): CredentialRevocation {
        const message = { publicKey: { oneofKind: undefined }, association: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CredentialRevocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CredentialRevocation): CredentialRevocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.publicKey = {
                        oneofKind: "installationKey",
                        installationKey: reader.bytes()
                    };
                    break;
                case /* bytes unsigned_legacy_create_identity_key */ 2:
                    message.publicKey = {
                        oneofKind: "unsignedLegacyCreateIdentityKey",
                        unsignedLegacyCreateIdentityKey: reader.bytes()
                    };
                    break;
                case /* xmtp.mls.message_contents.RevokeMessagingAccessAssociation messaging_access */ 3:
                    message.association = {
                        oneofKind: "messagingAccess",
                        messagingAccess: RevokeMessagingAccessAssociation.internalBinaryRead(reader, reader.uint32(), options, (message.association as any).messagingAccess)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CredentialRevocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.publicKey.oneofKind === "installationKey")
            writer.tag(1, WireType.LengthDelimited).bytes(message.publicKey.installationKey);
        /* bytes unsigned_legacy_create_identity_key = 2; */
        if (message.publicKey.oneofKind === "unsignedLegacyCreateIdentityKey")
            writer.tag(2, WireType.LengthDelimited).bytes(message.publicKey.unsignedLegacyCreateIdentityKey);
        /* xmtp.mls.message_contents.RevokeMessagingAccessAssociation messaging_access = 3; */
        if (message.association.oneofKind === "messagingAccess")
            RevokeMessagingAccessAssociation.internalBinaryWrite(message.association.messagingAccess, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.CredentialRevocation
 */
export const CredentialRevocation = new CredentialRevocation$Type();
