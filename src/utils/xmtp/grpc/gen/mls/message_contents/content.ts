// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "mls/message_contents/content.proto" (package "xmtp.mls.message_contents", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ContentTypeId is used to identify the type of content stored in a Message.
 *
 * @generated from protobuf message xmtp.mls.message_contents.ContentTypeId
 */
export interface ContentTypeId {
    /**
     * @generated from protobuf field: string authority_id = 1;
     */
    authorityId: string; // authority governing this content type
    /**
     * @generated from protobuf field: string type_id = 2;
     */
    typeId: string; // type identifier
    /**
     * @generated from protobuf field: uint32 version_major = 3;
     */
    versionMajor: number; // major version of the type
    /**
     * @generated from protobuf field: uint32 version_minor = 4;
     */
    versionMinor: number; // minor version of the type
}
/**
 * EncodedContent bundles the content with metadata identifying its type
 * and parameters required for correct decoding and presentation of the content.
 *
 * @generated from protobuf message xmtp.mls.message_contents.EncodedContent
 */
export interface EncodedContent {
    /**
     * content type identifier used to match the payload with
     * the correct decoding machinery
     *
     * @generated from protobuf field: xmtp.mls.message_contents.ContentTypeId type = 1;
     */
    type?: ContentTypeId;
    /**
     * optional encoding parameters required to correctly decode the content
     *
     * @generated from protobuf field: map<string, string> parameters = 2;
     */
    parameters: {
        [key: string]: string;
    };
    /**
     * optional fallback description of the content that can be used in case
     * the client cannot decode or render the content
     *
     * @generated from protobuf field: optional string fallback = 3;
     */
    fallback?: string;
    /**
     * optional compression; the value indicates algorithm used to
     * compress the encoded content bytes
     *
     * @generated from protobuf field: optional xmtp.mls.message_contents.Compression compression = 5;
     */
    compression?: Compression;
    /**
     * encoded content itself
     *
     * @generated from protobuf field: bytes content = 4;
     */
    content: Uint8Array;
}
/**
 * A PlaintextEnvelope is the outermost payload that gets encrypted by MLS
 *
 * @generated from protobuf message xmtp.mls.message_contents.PlaintextEnvelope
 */
export interface PlaintextEnvelope {
    /**
     * @generated from protobuf oneof: content
     */
    content: {
        oneofKind: "v1";
        /**
         * @generated from protobuf field: xmtp.mls.message_contents.PlaintextEnvelope.V1 v1 = 1;
         */
        v1: PlaintextEnvelope_V1;
    } | {
        oneofKind: "v2";
        /**
         * @generated from protobuf field: xmtp.mls.message_contents.PlaintextEnvelope.V2 v2 = 2;
         */
        v2: PlaintextEnvelope_V2;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Version 1 of the encrypted envelope
 *
 * @generated from protobuf message xmtp.mls.message_contents.PlaintextEnvelope.V1
 */
export interface PlaintextEnvelope_V1 {
    /**
     * Expected to be EncodedContent
     *
     * @generated from protobuf field: bytes content = 1;
     */
    content: Uint8Array;
    /**
     * A unique value that can be used to ensure that the same content can
     * produce different hashes. May be the sender timestamp.
     *
     * @generated from protobuf field: string idempotency_key = 2;
     */
    idempotencyKey: string;
}
/**
 * Version 2 of the encrypted envelope
 *
 * @generated from protobuf message xmtp.mls.message_contents.PlaintextEnvelope.V2
 */
export interface PlaintextEnvelope_V2 {
    /**
     * @generated from protobuf oneof: message_type
     */
    messageType: {
        oneofKind: "content";
        /**
         * Expected to be EncodedContent
         *
         * @generated from protobuf field: bytes content = 1;
         */
        content: Uint8Array;
    } | {
        oneofKind: "messageHistoryRequest";
        /**
         * Initiator sends the request to receive history
         *
         * @generated from protobuf field: xmtp.mls.message_contents.MessageHistoryRequest message_history_request = 2;
         */
        messageHistoryRequest: MessageHistoryRequest;
    } | {
        oneofKind: "messageHistoryResponse";
        /**
         * Other credentialed party sends response
         *
         * @generated from protobuf field: xmtp.mls.message_contents.MessageHistoryResponse message_history_response = 3;
         */
        messageHistoryResponse: MessageHistoryResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The initiator or new installation id that is requesting a history will send a
 * request
 *
 * @generated from protobuf message xmtp.mls.message_contents.MessageHistoryRequest
 */
export interface MessageHistoryRequest {
    /**
     * @generated from protobuf field: string request_id = 1;
     */
    requestId: string;
}
/**
 * Pre-existing installation id that is capable of supplying a history will send
 * this response
 *
 * @generated from protobuf message xmtp.mls.message_contents.MessageHistoryResponse
 */
export interface MessageHistoryResponse {
    /**
     * @generated from protobuf field: string request_id = 1;
     */
    requestId: string;
    /**
     * @generated from protobuf field: string backup_url = 2;
     */
    backupUrl: string;
    /**
     * @generated from protobuf field: bytes backup_file_hash = 3;
     */
    backupFileHash: Uint8Array;
    /**
     * @generated from protobuf field: int64 expiration_time_ns = 4;
     */
    expirationTimeNs: bigint;
}
/**
 * Recognized compression algorithms
 * protolint:disable ENUM_FIELD_NAMES_ZERO_VALUE_END_WITH
 *
 * @generated from protobuf enum xmtp.mls.message_contents.Compression
 */
export enum Compression {
    /**
     * @generated from protobuf enum value: COMPRESSION_DEFLATE = 0;
     */
    DEFLATE = 0,
    /**
     * @generated from protobuf enum value: COMPRESSION_GZIP = 1;
     */
    GZIP = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class ContentTypeId$Type extends MessageType<ContentTypeId> {
    constructor() {
        super("xmtp.mls.message_contents.ContentTypeId", [
            { no: 1, name: "authority_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "version_major", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "version_minor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ContentTypeId>): ContentTypeId {
        const message = { authorityId: "", typeId: "", versionMajor: 0, versionMinor: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ContentTypeId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ContentTypeId): ContentTypeId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string authority_id */ 1:
                    message.authorityId = reader.string();
                    break;
                case /* string type_id */ 2:
                    message.typeId = reader.string();
                    break;
                case /* uint32 version_major */ 3:
                    message.versionMajor = reader.uint32();
                    break;
                case /* uint32 version_minor */ 4:
                    message.versionMinor = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ContentTypeId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string authority_id = 1; */
        if (message.authorityId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.authorityId);
        /* string type_id = 2; */
        if (message.typeId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.typeId);
        /* uint32 version_major = 3; */
        if (message.versionMajor !== 0)
            writer.tag(3, WireType.Varint).uint32(message.versionMajor);
        /* uint32 version_minor = 4; */
        if (message.versionMinor !== 0)
            writer.tag(4, WireType.Varint).uint32(message.versionMinor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.ContentTypeId
 */
export const ContentTypeId = new ContentTypeId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncodedContent$Type extends MessageType<EncodedContent> {
    constructor() {
        super("xmtp.mls.message_contents.EncodedContent", [
            { no: 1, name: "type", kind: "message", T: () => ContentTypeId },
            { no: 2, name: "parameters", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 3, name: "fallback", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "compression", kind: "enum", opt: true, T: () => ["xmtp.mls.message_contents.Compression", Compression, "COMPRESSION_"] },
            { no: 4, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<EncodedContent>): EncodedContent {
        const message = { parameters: {}, content: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncodedContent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncodedContent): EncodedContent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.message_contents.ContentTypeId type */ 1:
                    message.type = ContentTypeId.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* map<string, string> parameters */ 2:
                    this.binaryReadMap2(message.parameters, reader, options);
                    break;
                case /* optional string fallback */ 3:
                    message.fallback = reader.string();
                    break;
                case /* optional xmtp.mls.message_contents.Compression compression */ 5:
                    message.compression = reader.int32();
                    break;
                case /* bytes content */ 4:
                    message.content = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: EncodedContent["parameters"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EncodedContent["parameters"] | undefined, val: EncodedContent["parameters"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field xmtp.mls.message_contents.EncodedContent.parameters");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: EncodedContent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.message_contents.ContentTypeId type = 1; */
        if (message.type)
            ContentTypeId.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, string> parameters = 2; */
        for (let k of Object.keys(message.parameters))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.parameters[k]).join();
        /* optional string fallback = 3; */
        if (message.fallback !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.fallback);
        /* optional xmtp.mls.message_contents.Compression compression = 5; */
        if (message.compression !== undefined)
            writer.tag(5, WireType.Varint).int32(message.compression);
        /* bytes content = 4; */
        if (message.content.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.EncodedContent
 */
export const EncodedContent = new EncodedContent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaintextEnvelope$Type extends MessageType<PlaintextEnvelope> {
    constructor() {
        super("xmtp.mls.message_contents.PlaintextEnvelope", [
            { no: 1, name: "v1", kind: "message", oneof: "content", T: () => PlaintextEnvelope_V1 },
            { no: 2, name: "v2", kind: "message", oneof: "content", T: () => PlaintextEnvelope_V2 }
        ]);
    }
    create(value?: PartialMessage<PlaintextEnvelope>): PlaintextEnvelope {
        const message = { content: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlaintextEnvelope>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaintextEnvelope): PlaintextEnvelope {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.message_contents.PlaintextEnvelope.V1 v1 */ 1:
                    message.content = {
                        oneofKind: "v1",
                        v1: PlaintextEnvelope_V1.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).v1)
                    };
                    break;
                case /* xmtp.mls.message_contents.PlaintextEnvelope.V2 v2 */ 2:
                    message.content = {
                        oneofKind: "v2",
                        v2: PlaintextEnvelope_V2.internalBinaryRead(reader, reader.uint32(), options, (message.content as any).v2)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaintextEnvelope, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.message_contents.PlaintextEnvelope.V1 v1 = 1; */
        if (message.content.oneofKind === "v1")
            PlaintextEnvelope_V1.internalBinaryWrite(message.content.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.mls.message_contents.PlaintextEnvelope.V2 v2 = 2; */
        if (message.content.oneofKind === "v2")
            PlaintextEnvelope_V2.internalBinaryWrite(message.content.v2, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.PlaintextEnvelope
 */
export const PlaintextEnvelope = new PlaintextEnvelope$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaintextEnvelope_V1$Type extends MessageType<PlaintextEnvelope_V1> {
    constructor() {
        super("xmtp.mls.message_contents.PlaintextEnvelope.V1", [
            { no: 1, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "idempotency_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlaintextEnvelope_V1>): PlaintextEnvelope_V1 {
        const message = { content: new Uint8Array(0), idempotencyKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlaintextEnvelope_V1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaintextEnvelope_V1): PlaintextEnvelope_V1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes content */ 1:
                    message.content = reader.bytes();
                    break;
                case /* string idempotency_key */ 2:
                    message.idempotencyKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaintextEnvelope_V1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes content = 1; */
        if (message.content.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.content);
        /* string idempotency_key = 2; */
        if (message.idempotencyKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.idempotencyKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.PlaintextEnvelope.V1
 */
export const PlaintextEnvelope_V1 = new PlaintextEnvelope_V1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaintextEnvelope_V2$Type extends MessageType<PlaintextEnvelope_V2> {
    constructor() {
        super("xmtp.mls.message_contents.PlaintextEnvelope.V2", [
            { no: 1, name: "content", kind: "scalar", oneof: "messageType", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "message_history_request", kind: "message", oneof: "messageType", T: () => MessageHistoryRequest },
            { no: 3, name: "message_history_response", kind: "message", oneof: "messageType", T: () => MessageHistoryResponse }
        ]);
    }
    create(value?: PartialMessage<PlaintextEnvelope_V2>): PlaintextEnvelope_V2 {
        const message = { messageType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlaintextEnvelope_V2>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaintextEnvelope_V2): PlaintextEnvelope_V2 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes content */ 1:
                    message.messageType = {
                        oneofKind: "content",
                        content: reader.bytes()
                    };
                    break;
                case /* xmtp.mls.message_contents.MessageHistoryRequest message_history_request */ 2:
                    message.messageType = {
                        oneofKind: "messageHistoryRequest",
                        messageHistoryRequest: MessageHistoryRequest.internalBinaryRead(reader, reader.uint32(), options, (message.messageType as any).messageHistoryRequest)
                    };
                    break;
                case /* xmtp.mls.message_contents.MessageHistoryResponse message_history_response */ 3:
                    message.messageType = {
                        oneofKind: "messageHistoryResponse",
                        messageHistoryResponse: MessageHistoryResponse.internalBinaryRead(reader, reader.uint32(), options, (message.messageType as any).messageHistoryResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaintextEnvelope_V2, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes content = 1; */
        if (message.messageType.oneofKind === "content")
            writer.tag(1, WireType.LengthDelimited).bytes(message.messageType.content);
        /* xmtp.mls.message_contents.MessageHistoryRequest message_history_request = 2; */
        if (message.messageType.oneofKind === "messageHistoryRequest")
            MessageHistoryRequest.internalBinaryWrite(message.messageType.messageHistoryRequest, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.mls.message_contents.MessageHistoryResponse message_history_response = 3; */
        if (message.messageType.oneofKind === "messageHistoryResponse")
            MessageHistoryResponse.internalBinaryWrite(message.messageType.messageHistoryResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.PlaintextEnvelope.V2
 */
export const PlaintextEnvelope_V2 = new PlaintextEnvelope_V2$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageHistoryRequest$Type extends MessageType<MessageHistoryRequest> {
    constructor() {
        super("xmtp.mls.message_contents.MessageHistoryRequest", [
            { no: 1, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageHistoryRequest>): MessageHistoryRequest {
        const message = { requestId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageHistoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageHistoryRequest): MessageHistoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.requestId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageHistoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string request_id = 1; */
        if (message.requestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.requestId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.MessageHistoryRequest
 */
export const MessageHistoryRequest = new MessageHistoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageHistoryResponse$Type extends MessageType<MessageHistoryResponse> {
    constructor() {
        super("xmtp.mls.message_contents.MessageHistoryResponse", [
            { no: 1, name: "request_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "backup_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "backup_file_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "expiration_time_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<MessageHistoryResponse>): MessageHistoryResponse {
        const message = { requestId: "", backupUrl: "", backupFileHash: new Uint8Array(0), expirationTimeNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MessageHistoryResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageHistoryResponse): MessageHistoryResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string request_id */ 1:
                    message.requestId = reader.string();
                    break;
                case /* string backup_url */ 2:
                    message.backupUrl = reader.string();
                    break;
                case /* bytes backup_file_hash */ 3:
                    message.backupFileHash = reader.bytes();
                    break;
                case /* int64 expiration_time_ns */ 4:
                    message.expirationTimeNs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageHistoryResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string request_id = 1; */
        if (message.requestId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.requestId);
        /* string backup_url = 2; */
        if (message.backupUrl !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.backupUrl);
        /* bytes backup_file_hash = 3; */
        if (message.backupFileHash.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.backupFileHash);
        /* int64 expiration_time_ns = 4; */
        if (message.expirationTimeNs !== 0n)
            writer.tag(4, WireType.Varint).int64(message.expirationTimeNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.message_contents.MessageHistoryResponse
 */
export const MessageHistoryResponse = new MessageHistoryResponse$Type();
