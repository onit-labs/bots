// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "mls/api/v1/mls.proto" (package "xmtp.mls.api.v1", syntax proto3)
// tslint:disable
import { Empty } from "../../../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Signature } from "../../../message_contents/signature";
/**
 * Full representation of a welcome message
 *
 * @generated from protobuf message xmtp.mls.api.v1.WelcomeMessage
 */
export interface WelcomeMessage {
    /**
     * @generated from protobuf oneof: version
     */
    version: {
        oneofKind: "v1";
        /**
         * @generated from protobuf field: xmtp.mls.api.v1.WelcomeMessage.V1 v1 = 1;
         */
        v1: WelcomeMessage_V1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Version 1 of the WelcomeMessage format
 *
 * @generated from protobuf message xmtp.mls.api.v1.WelcomeMessage.V1
 */
export interface WelcomeMessage_V1 {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: uint64 created_ns = 2;
     */
    createdNs: bigint;
    /**
     * @generated from protobuf field: bytes installation_key = 3;
     */
    installationKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes hpke_public_key = 5;
     */
    hpkePublicKey: Uint8Array;
}
/**
 * Input type for a welcome message
 *
 * @generated from protobuf message xmtp.mls.api.v1.WelcomeMessageInput
 */
export interface WelcomeMessageInput {
    /**
     * @generated from protobuf oneof: version
     */
    version: {
        oneofKind: "v1";
        /**
         * @generated from protobuf field: xmtp.mls.api.v1.WelcomeMessageInput.V1 v1 = 1;
         */
        v1: WelcomeMessageInput_V1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Version 1 of the WelcomeMessageInput format
 *
 * @generated from protobuf message xmtp.mls.api.v1.WelcomeMessageInput.V1
 */
export interface WelcomeMessageInput_V1 {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes hpke_public_key = 3;
     */
    hpkePublicKey: Uint8Array;
}
/**
 * Full representation of a group message
 *
 * @generated from protobuf message xmtp.mls.api.v1.GroupMessage
 */
export interface GroupMessage {
    /**
     * @generated from protobuf oneof: version
     */
    version: {
        oneofKind: "v1";
        /**
         * @generated from protobuf field: xmtp.mls.api.v1.GroupMessage.V1 v1 = 1;
         */
        v1: GroupMessage_V1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Version 1 of the GroupMessage format
 *
 * @generated from protobuf message xmtp.mls.api.v1.GroupMessage.V1
 */
export interface GroupMessage_V1 {
    /**
     * @generated from protobuf field: uint64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf field: uint64 created_ns = 2;
     */
    createdNs: bigint;
    /**
     * @generated from protobuf field: bytes group_id = 3;
     */
    groupId: Uint8Array;
    /**
     * @generated from protobuf field: bytes data = 4;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes sender_hmac = 5;
     */
    senderHmac: Uint8Array;
}
/**
 * Input type for a group message
 *
 * @generated from protobuf message xmtp.mls.api.v1.GroupMessageInput
 */
export interface GroupMessageInput {
    /**
     * @generated from protobuf oneof: version
     */
    version: {
        oneofKind: "v1";
        /**
         * @generated from protobuf field: xmtp.mls.api.v1.GroupMessageInput.V1 v1 = 1;
         */
        v1: GroupMessageInput_V1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Version 1 of the GroupMessageInput payload format
 *
 * @generated from protobuf message xmtp.mls.api.v1.GroupMessageInput.V1
 */
export interface GroupMessageInput_V1 {
    /**
     * @generated from protobuf field: bytes data = 1;
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bytes sender_hmac = 2;
     */
    senderHmac: Uint8Array;
}
/**
 * Send a batch of MLS messages
 *
 * @generated from protobuf message xmtp.mls.api.v1.SendGroupMessagesRequest
 */
export interface SendGroupMessagesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.GroupMessageInput messages = 1;
     */
    messages: GroupMessageInput[];
}
/**
 * Send a batch of welcome messages
 *
 * @generated from protobuf message xmtp.mls.api.v1.SendWelcomeMessagesRequest
 */
export interface SendWelcomeMessagesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.WelcomeMessageInput messages = 1;
     */
    messages: WelcomeMessageInput[];
}
/**
 * A wrapper around the Key Package bytes
 *
 * This would be a serialized MLS key package that the node would
 * parse, validate, and then store.
 *
 * @generated from protobuf message xmtp.mls.api.v1.KeyPackageUpload
 */
export interface KeyPackageUpload {
    /**
     * The owner's wallet address would be extracted from the identity
     * credential in the key package, and all signatures would be validated.
     *
     * @generated from protobuf field: bytes key_package_tls_serialized = 1;
     */
    keyPackageTlsSerialized: Uint8Array;
}
/**
 * Register a new installation
 *
 * @generated from protobuf message xmtp.mls.api.v1.RegisterInstallationRequest
 */
export interface RegisterInstallationRequest {
    /**
     * The Key Package contains all information needed to register an installation
     *
     * @generated from protobuf field: xmtp.mls.api.v1.KeyPackageUpload key_package = 1;
     */
    keyPackage?: KeyPackageUpload;
}
/**
 * The response to a RegisterInstallationRequest
 *
 * @generated from protobuf message xmtp.mls.api.v1.RegisterInstallationResponse
 */
export interface RegisterInstallationResponse {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
}
/**
 * Upload a new key packages
 *
 * @generated from protobuf message xmtp.mls.api.v1.UploadKeyPackageRequest
 */
export interface UploadKeyPackageRequest {
    /**
     * An individual key package upload request
     *
     * @generated from protobuf field: xmtp.mls.api.v1.KeyPackageUpload key_package = 1;
     */
    keyPackage?: KeyPackageUpload;
}
/**
 * Fetch one or more key packages
 *
 * @generated from protobuf message xmtp.mls.api.v1.FetchKeyPackagesRequest
 */
export interface FetchKeyPackagesRequest {
    /**
     * The caller can provide an array of installation keys, and the API
     * will return one key package for each installation associated with each
     * installation key
     *
     * @generated from protobuf field: repeated bytes installation_keys = 1;
     */
    installationKeys: Uint8Array[];
}
/**
 * The response to a FetchKeyPackagesRequest
 *
 * @generated from protobuf message xmtp.mls.api.v1.FetchKeyPackagesResponse
 */
export interface FetchKeyPackagesResponse {
    /**
     * Returns one key package per installation in the original order of the
     * request. If any installations are missing key packages, an empty entry is
     * left in their respective spots in the array.
     *
     * @generated from protobuf field: repeated xmtp.mls.api.v1.FetchKeyPackagesResponse.KeyPackage key_packages = 1;
     */
    keyPackages: FetchKeyPackagesResponse_KeyPackage[];
}
/**
 * An individual key package
 *
 * @generated from protobuf message xmtp.mls.api.v1.FetchKeyPackagesResponse.KeyPackage
 */
export interface FetchKeyPackagesResponse_KeyPackage {
    /**
     * @generated from protobuf field: bytes key_package_tls_serialized = 1;
     */
    keyPackageTlsSerialized: Uint8Array;
}
/**
 * Revoke an installation
 *
 * @generated from protobuf message xmtp.mls.api.v1.RevokeInstallationRequest
 */
export interface RevokeInstallationRequest {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
    /**
     * All revocations must be validated with a wallet signature over the
     * installation_id being revoked (and some sort of standard prologue)
     *
     * @generated from protobuf field: xmtp.message_contents.Signature wallet_signature = 2;
     */
    walletSignature?: Signature;
}
/**
 * Get all updates for an identity since the specified time
 *
 * @generated from protobuf message xmtp.mls.api.v1.GetIdentityUpdatesRequest
 */
export interface GetIdentityUpdatesRequest {
    /**
     * @generated from protobuf field: repeated string account_addresses = 1;
     */
    accountAddresses: string[];
    /**
     * @generated from protobuf field: uint64 start_time_ns = 2;
     */
    startTimeNs: bigint;
}
/**
 * Used to get any new or revoked installations for a list of wallet addresses
 *
 * @generated from protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse
 */
export interface GetIdentityUpdatesResponse {
    /**
     * A list of updates (or empty objects if no changes) in the original order
     * of the request
     *
     * @generated from protobuf field: repeated xmtp.mls.api.v1.GetIdentityUpdatesResponse.WalletUpdates updates = 1;
     */
    updates: GetIdentityUpdatesResponse_WalletUpdates[];
}
/**
 * A new installation key was seen for the first time by the nodes
 *
 * @generated from protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.NewInstallationUpdate
 */
export interface GetIdentityUpdatesResponse_NewInstallationUpdate {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
    /**
     * @generated from protobuf field: bytes credential_identity = 2;
     */
    credentialIdentity: Uint8Array;
}
/**
 * An installation was revoked
 *
 * @generated from protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.RevokedInstallationUpdate
 */
export interface GetIdentityUpdatesResponse_RevokedInstallationUpdate {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
}
/**
 * A wrapper for any update to the wallet
 *
 * @generated from protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.Update
 */
export interface GetIdentityUpdatesResponse_Update {
    /**
     * @generated from protobuf field: uint64 timestamp_ns = 1;
     */
    timestampNs: bigint;
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "newInstallation";
        /**
         * @generated from protobuf field: xmtp.mls.api.v1.GetIdentityUpdatesResponse.NewInstallationUpdate new_installation = 2;
         */
        newInstallation: GetIdentityUpdatesResponse_NewInstallationUpdate;
    } | {
        oneofKind: "revokedInstallation";
        /**
         * @generated from protobuf field: xmtp.mls.api.v1.GetIdentityUpdatesResponse.RevokedInstallationUpdate revoked_installation = 3;
         */
        revokedInstallation: GetIdentityUpdatesResponse_RevokedInstallationUpdate;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A wrapper for the updates for a single wallet
 *
 * @generated from protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.WalletUpdates
 */
export interface GetIdentityUpdatesResponse_WalletUpdates {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.GetIdentityUpdatesResponse.Update updates = 1;
     */
    updates: GetIdentityUpdatesResponse_Update[];
}
/**
 * Pagination config for queries
 *
 * @generated from protobuf message xmtp.mls.api.v1.PagingInfo
 */
export interface PagingInfo {
    /**
     * @generated from protobuf field: xmtp.mls.api.v1.SortDirection direction = 1;
     */
    direction: SortDirection;
    /**
     * @generated from protobuf field: uint32 limit = 2;
     */
    limit: number;
    /**
     * @generated from protobuf field: uint64 id_cursor = 3;
     */
    idCursor: bigint;
}
/**
 * Request for group message queries
 *
 * @generated from protobuf message xmtp.mls.api.v1.QueryGroupMessagesRequest
 */
export interface QueryGroupMessagesRequest {
    /**
     * @generated from protobuf field: bytes group_id = 1;
     */
    groupId: Uint8Array;
    /**
     * @generated from protobuf field: xmtp.mls.api.v1.PagingInfo paging_info = 2;
     */
    pagingInfo?: PagingInfo;
}
/**
 * Response for group message queries
 *
 * @generated from protobuf message xmtp.mls.api.v1.QueryGroupMessagesResponse
 */
export interface QueryGroupMessagesResponse {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.GroupMessage messages = 1;
     */
    messages: GroupMessage[];
    /**
     * @generated from protobuf field: xmtp.mls.api.v1.PagingInfo paging_info = 2;
     */
    pagingInfo?: PagingInfo;
}
/**
 * Request for welcome message queries
 *
 * @generated from protobuf message xmtp.mls.api.v1.QueryWelcomeMessagesRequest
 */
export interface QueryWelcomeMessagesRequest {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
    /**
     * @generated from protobuf field: xmtp.mls.api.v1.PagingInfo paging_info = 2;
     */
    pagingInfo?: PagingInfo;
}
/**
 * Response for welcome message queries
 *
 * @generated from protobuf message xmtp.mls.api.v1.QueryWelcomeMessagesResponse
 */
export interface QueryWelcomeMessagesResponse {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.WelcomeMessage messages = 1;
     */
    messages: WelcomeMessage[];
    /**
     * @generated from protobuf field: xmtp.mls.api.v1.PagingInfo paging_info = 2;
     */
    pagingInfo?: PagingInfo;
}
/**
 * Request for subscribing to group messages
 *
 * @generated from protobuf message xmtp.mls.api.v1.SubscribeGroupMessagesRequest
 */
export interface SubscribeGroupMessagesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.SubscribeGroupMessagesRequest.Filter filters = 1;
     */
    filters: SubscribeGroupMessagesRequest_Filter[];
}
/**
 * Subscription filter
 *
 * @generated from protobuf message xmtp.mls.api.v1.SubscribeGroupMessagesRequest.Filter
 */
export interface SubscribeGroupMessagesRequest_Filter {
    /**
     * @generated from protobuf field: bytes group_id = 1;
     */
    groupId: Uint8Array;
    /**
     * @generated from protobuf field: uint64 id_cursor = 2;
     */
    idCursor: bigint;
}
/**
 * Request for subscribing to welcome messages
 *
 * @generated from protobuf message xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest
 */
export interface SubscribeWelcomeMessagesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest.Filter filters = 1;
     */
    filters: SubscribeWelcomeMessagesRequest_Filter[];
}
/**
 * Subscription filter
 *
 * @generated from protobuf message xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest.Filter
 */
export interface SubscribeWelcomeMessagesRequest_Filter {
    /**
     * @generated from protobuf field: bytes installation_key = 1;
     */
    installationKey: Uint8Array;
    /**
     * @generated from protobuf field: uint64 id_cursor = 2;
     */
    idCursor: bigint;
}
/**
 * Sort direction for queries
 *
 * @generated from protobuf enum xmtp.mls.api.v1.SortDirection
 */
export enum SortDirection {
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_ASCENDING = 1;
     */
    ASCENDING = 1,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_DESCENDING = 2;
     */
    DESCENDING = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class WelcomeMessage$Type extends MessageType<WelcomeMessage> {
    constructor() {
        super("xmtp.mls.api.v1.WelcomeMessage", [
            { no: 1, name: "v1", kind: "message", oneof: "version", T: () => WelcomeMessage_V1 }
        ]);
    }
    create(value?: PartialMessage<WelcomeMessage>): WelcomeMessage {
        const message = { version: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WelcomeMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WelcomeMessage): WelcomeMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.WelcomeMessage.V1 v1 */ 1:
                    message.version = {
                        oneofKind: "v1",
                        v1: WelcomeMessage_V1.internalBinaryRead(reader, reader.uint32(), options, (message.version as any).v1)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WelcomeMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.WelcomeMessage.V1 v1 = 1; */
        if (message.version.oneofKind === "v1")
            WelcomeMessage_V1.internalBinaryWrite(message.version.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.WelcomeMessage
 */
export const WelcomeMessage = new WelcomeMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WelcomeMessage_V1$Type extends MessageType<WelcomeMessage_V1> {
    constructor() {
        super("xmtp.mls.api.v1.WelcomeMessage.V1", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "created_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "hpke_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<WelcomeMessage_V1>): WelcomeMessage_V1 {
        const message = { id: 0n, createdNs: 0n, installationKey: new Uint8Array(0), data: new Uint8Array(0), hpkePublicKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WelcomeMessage_V1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WelcomeMessage_V1): WelcomeMessage_V1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_ns */ 2:
                    message.createdNs = reader.uint64().toBigInt();
                    break;
                case /* bytes installation_key */ 3:
                    message.installationKey = reader.bytes();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* bytes hpke_public_key */ 5:
                    message.hpkePublicKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WelcomeMessage_V1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 created_ns = 2; */
        if (message.createdNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.createdNs);
        /* bytes installation_key = 3; */
        if (message.installationKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.installationKey);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* bytes hpke_public_key = 5; */
        if (message.hpkePublicKey.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.hpkePublicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.WelcomeMessage.V1
 */
export const WelcomeMessage_V1 = new WelcomeMessage_V1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WelcomeMessageInput$Type extends MessageType<WelcomeMessageInput> {
    constructor() {
        super("xmtp.mls.api.v1.WelcomeMessageInput", [
            { no: 1, name: "v1", kind: "message", oneof: "version", T: () => WelcomeMessageInput_V1 }
        ]);
    }
    create(value?: PartialMessage<WelcomeMessageInput>): WelcomeMessageInput {
        const message = { version: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WelcomeMessageInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WelcomeMessageInput): WelcomeMessageInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.WelcomeMessageInput.V1 v1 */ 1:
                    message.version = {
                        oneofKind: "v1",
                        v1: WelcomeMessageInput_V1.internalBinaryRead(reader, reader.uint32(), options, (message.version as any).v1)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WelcomeMessageInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.WelcomeMessageInput.V1 v1 = 1; */
        if (message.version.oneofKind === "v1")
            WelcomeMessageInput_V1.internalBinaryWrite(message.version.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.WelcomeMessageInput
 */
export const WelcomeMessageInput = new WelcomeMessageInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WelcomeMessageInput_V1$Type extends MessageType<WelcomeMessageInput_V1> {
    constructor() {
        super("xmtp.mls.api.v1.WelcomeMessageInput.V1", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "hpke_public_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<WelcomeMessageInput_V1>): WelcomeMessageInput_V1 {
        const message = { installationKey: new Uint8Array(0), data: new Uint8Array(0), hpkePublicKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WelcomeMessageInput_V1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WelcomeMessageInput_V1): WelcomeMessageInput_V1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* bytes hpke_public_key */ 3:
                    message.hpkePublicKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WelcomeMessageInput_V1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* bytes hpke_public_key = 3; */
        if (message.hpkePublicKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.hpkePublicKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.WelcomeMessageInput.V1
 */
export const WelcomeMessageInput_V1 = new WelcomeMessageInput_V1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupMessage$Type extends MessageType<GroupMessage> {
    constructor() {
        super("xmtp.mls.api.v1.GroupMessage", [
            { no: 1, name: "v1", kind: "message", oneof: "version", T: () => GroupMessage_V1 }
        ]);
    }
    create(value?: PartialMessage<GroupMessage>): GroupMessage {
        const message = { version: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupMessage): GroupMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.GroupMessage.V1 v1 */ 1:
                    message.version = {
                        oneofKind: "v1",
                        v1: GroupMessage_V1.internalBinaryRead(reader, reader.uint32(), options, (message.version as any).v1)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.GroupMessage.V1 v1 = 1; */
        if (message.version.oneofKind === "v1")
            GroupMessage_V1.internalBinaryWrite(message.version.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GroupMessage
 */
export const GroupMessage = new GroupMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupMessage_V1$Type extends MessageType<GroupMessage_V1> {
    constructor() {
        super("xmtp.mls.api.v1.GroupMessage.V1", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "created_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "group_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "sender_hmac", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GroupMessage_V1>): GroupMessage_V1 {
        const message = { id: 0n, createdNs: 0n, groupId: new Uint8Array(0), data: new Uint8Array(0), senderHmac: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupMessage_V1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupMessage_V1): GroupMessage_V1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* uint64 created_ns */ 2:
                    message.createdNs = reader.uint64().toBigInt();
                    break;
                case /* bytes group_id */ 3:
                    message.groupId = reader.bytes();
                    break;
                case /* bytes data */ 4:
                    message.data = reader.bytes();
                    break;
                case /* bytes sender_hmac */ 5:
                    message.senderHmac = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupMessage_V1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* uint64 created_ns = 2; */
        if (message.createdNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.createdNs);
        /* bytes group_id = 3; */
        if (message.groupId.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.groupId);
        /* bytes data = 4; */
        if (message.data.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.data);
        /* bytes sender_hmac = 5; */
        if (message.senderHmac.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.senderHmac);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GroupMessage.V1
 */
export const GroupMessage_V1 = new GroupMessage_V1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupMessageInput$Type extends MessageType<GroupMessageInput> {
    constructor() {
        super("xmtp.mls.api.v1.GroupMessageInput", [
            { no: 1, name: "v1", kind: "message", oneof: "version", T: () => GroupMessageInput_V1 }
        ]);
    }
    create(value?: PartialMessage<GroupMessageInput>): GroupMessageInput {
        const message = { version: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupMessageInput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupMessageInput): GroupMessageInput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.GroupMessageInput.V1 v1 */ 1:
                    message.version = {
                        oneofKind: "v1",
                        v1: GroupMessageInput_V1.internalBinaryRead(reader, reader.uint32(), options, (message.version as any).v1)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupMessageInput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.GroupMessageInput.V1 v1 = 1; */
        if (message.version.oneofKind === "v1")
            GroupMessageInput_V1.internalBinaryWrite(message.version.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GroupMessageInput
 */
export const GroupMessageInput = new GroupMessageInput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GroupMessageInput_V1$Type extends MessageType<GroupMessageInput_V1> {
    constructor() {
        super("xmtp.mls.api.v1.GroupMessageInput.V1", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sender_hmac", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GroupMessageInput_V1>): GroupMessageInput_V1 {
        const message = { data: new Uint8Array(0), senderHmac: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GroupMessageInput_V1>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GroupMessageInput_V1): GroupMessageInput_V1 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* bytes sender_hmac */ 2:
                    message.senderHmac = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GroupMessageInput_V1, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* bytes sender_hmac = 2; */
        if (message.senderHmac.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.senderHmac);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GroupMessageInput.V1
 */
export const GroupMessageInput_V1 = new GroupMessageInput_V1$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendGroupMessagesRequest$Type extends MessageType<SendGroupMessagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.SendGroupMessagesRequest", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GroupMessageInput }
        ]);
    }
    create(value?: PartialMessage<SendGroupMessagesRequest>): SendGroupMessagesRequest {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendGroupMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendGroupMessagesRequest): SendGroupMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.GroupMessageInput messages */ 1:
                    message.messages.push(GroupMessageInput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendGroupMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.GroupMessageInput messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            GroupMessageInput.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.SendGroupMessagesRequest
 */
export const SendGroupMessagesRequest = new SendGroupMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SendWelcomeMessagesRequest$Type extends MessageType<SendWelcomeMessagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.SendWelcomeMessagesRequest", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WelcomeMessageInput }
        ]);
    }
    create(value?: PartialMessage<SendWelcomeMessagesRequest>): SendWelcomeMessagesRequest {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SendWelcomeMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SendWelcomeMessagesRequest): SendWelcomeMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.WelcomeMessageInput messages */ 1:
                    message.messages.push(WelcomeMessageInput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SendWelcomeMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.WelcomeMessageInput messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            WelcomeMessageInput.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.SendWelcomeMessagesRequest
 */
export const SendWelcomeMessagesRequest = new SendWelcomeMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyPackageUpload$Type extends MessageType<KeyPackageUpload> {
    constructor() {
        super("xmtp.mls.api.v1.KeyPackageUpload", [
            { no: 1, name: "key_package_tls_serialized", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<KeyPackageUpload>): KeyPackageUpload {
        const message = { keyPackageTlsSerialized: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeyPackageUpload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyPackageUpload): KeyPackageUpload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key_package_tls_serialized */ 1:
                    message.keyPackageTlsSerialized = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyPackageUpload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key_package_tls_serialized = 1; */
        if (message.keyPackageTlsSerialized.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyPackageTlsSerialized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.KeyPackageUpload
 */
export const KeyPackageUpload = new KeyPackageUpload$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterInstallationRequest$Type extends MessageType<RegisterInstallationRequest> {
    constructor() {
        super("xmtp.mls.api.v1.RegisterInstallationRequest", [
            { no: 1, name: "key_package", kind: "message", T: () => KeyPackageUpload }
        ]);
    }
    create(value?: PartialMessage<RegisterInstallationRequest>): RegisterInstallationRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterInstallationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterInstallationRequest): RegisterInstallationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.KeyPackageUpload key_package */ 1:
                    message.keyPackage = KeyPackageUpload.internalBinaryRead(reader, reader.uint32(), options, message.keyPackage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterInstallationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.KeyPackageUpload key_package = 1; */
        if (message.keyPackage)
            KeyPackageUpload.internalBinaryWrite(message.keyPackage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.RegisterInstallationRequest
 */
export const RegisterInstallationRequest = new RegisterInstallationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterInstallationResponse$Type extends MessageType<RegisterInstallationResponse> {
    constructor() {
        super("xmtp.mls.api.v1.RegisterInstallationResponse", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterInstallationResponse>): RegisterInstallationResponse {
        const message = { installationKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RegisterInstallationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterInstallationResponse): RegisterInstallationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterInstallationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.RegisterInstallationResponse
 */
export const RegisterInstallationResponse = new RegisterInstallationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UploadKeyPackageRequest$Type extends MessageType<UploadKeyPackageRequest> {
    constructor() {
        super("xmtp.mls.api.v1.UploadKeyPackageRequest", [
            { no: 1, name: "key_package", kind: "message", T: () => KeyPackageUpload }
        ]);
    }
    create(value?: PartialMessage<UploadKeyPackageRequest>): UploadKeyPackageRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UploadKeyPackageRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UploadKeyPackageRequest): UploadKeyPackageRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.KeyPackageUpload key_package */ 1:
                    message.keyPackage = KeyPackageUpload.internalBinaryRead(reader, reader.uint32(), options, message.keyPackage);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UploadKeyPackageRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.KeyPackageUpload key_package = 1; */
        if (message.keyPackage)
            KeyPackageUpload.internalBinaryWrite(message.keyPackage, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.UploadKeyPackageRequest
 */
export const UploadKeyPackageRequest = new UploadKeyPackageRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchKeyPackagesRequest$Type extends MessageType<FetchKeyPackagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.FetchKeyPackagesRequest", [
            { no: 1, name: "installation_keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FetchKeyPackagesRequest>): FetchKeyPackagesRequest {
        const message = { installationKeys: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchKeyPackagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchKeyPackagesRequest): FetchKeyPackagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes installation_keys */ 1:
                    message.installationKeys.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchKeyPackagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes installation_keys = 1; */
        for (let i = 0; i < message.installationKeys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKeys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.FetchKeyPackagesRequest
 */
export const FetchKeyPackagesRequest = new FetchKeyPackagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchKeyPackagesResponse$Type extends MessageType<FetchKeyPackagesResponse> {
    constructor() {
        super("xmtp.mls.api.v1.FetchKeyPackagesResponse", [
            { no: 1, name: "key_packages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FetchKeyPackagesResponse_KeyPackage }
        ]);
    }
    create(value?: PartialMessage<FetchKeyPackagesResponse>): FetchKeyPackagesResponse {
        const message = { keyPackages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchKeyPackagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchKeyPackagesResponse): FetchKeyPackagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.FetchKeyPackagesResponse.KeyPackage key_packages */ 1:
                    message.keyPackages.push(FetchKeyPackagesResponse_KeyPackage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchKeyPackagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.FetchKeyPackagesResponse.KeyPackage key_packages = 1; */
        for (let i = 0; i < message.keyPackages.length; i++)
            FetchKeyPackagesResponse_KeyPackage.internalBinaryWrite(message.keyPackages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.FetchKeyPackagesResponse
 */
export const FetchKeyPackagesResponse = new FetchKeyPackagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchKeyPackagesResponse_KeyPackage$Type extends MessageType<FetchKeyPackagesResponse_KeyPackage> {
    constructor() {
        super("xmtp.mls.api.v1.FetchKeyPackagesResponse.KeyPackage", [
            { no: 1, name: "key_package_tls_serialized", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FetchKeyPackagesResponse_KeyPackage>): FetchKeyPackagesResponse_KeyPackage {
        const message = { keyPackageTlsSerialized: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchKeyPackagesResponse_KeyPackage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchKeyPackagesResponse_KeyPackage): FetchKeyPackagesResponse_KeyPackage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key_package_tls_serialized */ 1:
                    message.keyPackageTlsSerialized = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchKeyPackagesResponse_KeyPackage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key_package_tls_serialized = 1; */
        if (message.keyPackageTlsSerialized.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyPackageTlsSerialized);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.FetchKeyPackagesResponse.KeyPackage
 */
export const FetchKeyPackagesResponse_KeyPackage = new FetchKeyPackagesResponse_KeyPackage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RevokeInstallationRequest$Type extends MessageType<RevokeInstallationRequest> {
    constructor() {
        super("xmtp.mls.api.v1.RevokeInstallationRequest", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "wallet_signature", kind: "message", T: () => Signature }
        ]);
    }
    create(value?: PartialMessage<RevokeInstallationRequest>): RevokeInstallationRequest {
        const message = { installationKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RevokeInstallationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RevokeInstallationRequest): RevokeInstallationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                case /* xmtp.message_contents.Signature wallet_signature */ 2:
                    message.walletSignature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.walletSignature);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RevokeInstallationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        /* xmtp.message_contents.Signature wallet_signature = 2; */
        if (message.walletSignature)
            Signature.internalBinaryWrite(message.walletSignature, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.RevokeInstallationRequest
 */
export const RevokeInstallationRequest = new RevokeInstallationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentityUpdatesRequest$Type extends MessageType<GetIdentityUpdatesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.GetIdentityUpdatesRequest", [
            { no: 1, name: "account_addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "start_time_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetIdentityUpdatesRequest>): GetIdentityUpdatesRequest {
        const message = { accountAddresses: [], startTimeNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIdentityUpdatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentityUpdatesRequest): GetIdentityUpdatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string account_addresses */ 1:
                    message.accountAddresses.push(reader.string());
                    break;
                case /* uint64 start_time_ns */ 2:
                    message.startTimeNs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentityUpdatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string account_addresses = 1; */
        for (let i = 0; i < message.accountAddresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.accountAddresses[i]);
        /* uint64 start_time_ns = 2; */
        if (message.startTimeNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.startTimeNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GetIdentityUpdatesRequest
 */
export const GetIdentityUpdatesRequest = new GetIdentityUpdatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentityUpdatesResponse$Type extends MessageType<GetIdentityUpdatesResponse> {
    constructor() {
        super("xmtp.mls.api.v1.GetIdentityUpdatesResponse", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetIdentityUpdatesResponse_WalletUpdates }
        ]);
    }
    create(value?: PartialMessage<GetIdentityUpdatesResponse>): GetIdentityUpdatesResponse {
        const message = { updates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIdentityUpdatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentityUpdatesResponse): GetIdentityUpdatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.GetIdentityUpdatesResponse.WalletUpdates updates */ 1:
                    message.updates.push(GetIdentityUpdatesResponse_WalletUpdates.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentityUpdatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.GetIdentityUpdatesResponse.WalletUpdates updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            GetIdentityUpdatesResponse_WalletUpdates.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse
 */
export const GetIdentityUpdatesResponse = new GetIdentityUpdatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentityUpdatesResponse_NewInstallationUpdate$Type extends MessageType<GetIdentityUpdatesResponse_NewInstallationUpdate> {
    constructor() {
        super("xmtp.mls.api.v1.GetIdentityUpdatesResponse.NewInstallationUpdate", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "credential_identity", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetIdentityUpdatesResponse_NewInstallationUpdate>): GetIdentityUpdatesResponse_NewInstallationUpdate {
        const message = { installationKey: new Uint8Array(0), credentialIdentity: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIdentityUpdatesResponse_NewInstallationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentityUpdatesResponse_NewInstallationUpdate): GetIdentityUpdatesResponse_NewInstallationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                case /* bytes credential_identity */ 2:
                    message.credentialIdentity = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentityUpdatesResponse_NewInstallationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        /* bytes credential_identity = 2; */
        if (message.credentialIdentity.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.credentialIdentity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.NewInstallationUpdate
 */
export const GetIdentityUpdatesResponse_NewInstallationUpdate = new GetIdentityUpdatesResponse_NewInstallationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentityUpdatesResponse_RevokedInstallationUpdate$Type extends MessageType<GetIdentityUpdatesResponse_RevokedInstallationUpdate> {
    constructor() {
        super("xmtp.mls.api.v1.GetIdentityUpdatesResponse.RevokedInstallationUpdate", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetIdentityUpdatesResponse_RevokedInstallationUpdate>): GetIdentityUpdatesResponse_RevokedInstallationUpdate {
        const message = { installationKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIdentityUpdatesResponse_RevokedInstallationUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentityUpdatesResponse_RevokedInstallationUpdate): GetIdentityUpdatesResponse_RevokedInstallationUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentityUpdatesResponse_RevokedInstallationUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.RevokedInstallationUpdate
 */
export const GetIdentityUpdatesResponse_RevokedInstallationUpdate = new GetIdentityUpdatesResponse_RevokedInstallationUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentityUpdatesResponse_Update$Type extends MessageType<GetIdentityUpdatesResponse_Update> {
    constructor() {
        super("xmtp.mls.api.v1.GetIdentityUpdatesResponse.Update", [
            { no: 1, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "new_installation", kind: "message", oneof: "kind", T: () => GetIdentityUpdatesResponse_NewInstallationUpdate },
            { no: 3, name: "revoked_installation", kind: "message", oneof: "kind", T: () => GetIdentityUpdatesResponse_RevokedInstallationUpdate }
        ]);
    }
    create(value?: PartialMessage<GetIdentityUpdatesResponse_Update>): GetIdentityUpdatesResponse_Update {
        const message = { timestampNs: 0n, kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIdentityUpdatesResponse_Update>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentityUpdatesResponse_Update): GetIdentityUpdatesResponse_Update {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp_ns */ 1:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                case /* xmtp.mls.api.v1.GetIdentityUpdatesResponse.NewInstallationUpdate new_installation */ 2:
                    message.kind = {
                        oneofKind: "newInstallation",
                        newInstallation: GetIdentityUpdatesResponse_NewInstallationUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).newInstallation)
                    };
                    break;
                case /* xmtp.mls.api.v1.GetIdentityUpdatesResponse.RevokedInstallationUpdate revoked_installation */ 3:
                    message.kind = {
                        oneofKind: "revokedInstallation",
                        revokedInstallation: GetIdentityUpdatesResponse_RevokedInstallationUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).revokedInstallation)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentityUpdatesResponse_Update, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp_ns = 1; */
        if (message.timestampNs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestampNs);
        /* xmtp.mls.api.v1.GetIdentityUpdatesResponse.NewInstallationUpdate new_installation = 2; */
        if (message.kind.oneofKind === "newInstallation")
            GetIdentityUpdatesResponse_NewInstallationUpdate.internalBinaryWrite(message.kind.newInstallation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.mls.api.v1.GetIdentityUpdatesResponse.RevokedInstallationUpdate revoked_installation = 3; */
        if (message.kind.oneofKind === "revokedInstallation")
            GetIdentityUpdatesResponse_RevokedInstallationUpdate.internalBinaryWrite(message.kind.revokedInstallation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.Update
 */
export const GetIdentityUpdatesResponse_Update = new GetIdentityUpdatesResponse_Update$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIdentityUpdatesResponse_WalletUpdates$Type extends MessageType<GetIdentityUpdatesResponse_WalletUpdates> {
    constructor() {
        super("xmtp.mls.api.v1.GetIdentityUpdatesResponse.WalletUpdates", [
            { no: 1, name: "updates", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetIdentityUpdatesResponse_Update }
        ]);
    }
    create(value?: PartialMessage<GetIdentityUpdatesResponse_WalletUpdates>): GetIdentityUpdatesResponse_WalletUpdates {
        const message = { updates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIdentityUpdatesResponse_WalletUpdates>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIdentityUpdatesResponse_WalletUpdates): GetIdentityUpdatesResponse_WalletUpdates {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.GetIdentityUpdatesResponse.Update updates */ 1:
                    message.updates.push(GetIdentityUpdatesResponse_Update.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIdentityUpdatesResponse_WalletUpdates, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.GetIdentityUpdatesResponse.Update updates = 1; */
        for (let i = 0; i < message.updates.length; i++)
            GetIdentityUpdatesResponse_Update.internalBinaryWrite(message.updates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.GetIdentityUpdatesResponse.WalletUpdates
 */
export const GetIdentityUpdatesResponse_WalletUpdates = new GetIdentityUpdatesResponse_WalletUpdates$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PagingInfo$Type extends MessageType<PagingInfo> {
    constructor() {
        super("xmtp.mls.api.v1.PagingInfo", [
            { no: 1, name: "direction", kind: "enum", T: () => ["xmtp.mls.api.v1.SortDirection", SortDirection, "SORT_DIRECTION_"] },
            { no: 2, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "id_cursor", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PagingInfo>): PagingInfo {
        const message = { direction: 0, limit: 0, idCursor: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PagingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PagingInfo): PagingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.mls.api.v1.SortDirection direction */ 1:
                    message.direction = reader.int32();
                    break;
                case /* uint32 limit */ 2:
                    message.limit = reader.uint32();
                    break;
                case /* uint64 id_cursor */ 3:
                    message.idCursor = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PagingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.mls.api.v1.SortDirection direction = 1; */
        if (message.direction !== 0)
            writer.tag(1, WireType.Varint).int32(message.direction);
        /* uint32 limit = 2; */
        if (message.limit !== 0)
            writer.tag(2, WireType.Varint).uint32(message.limit);
        /* uint64 id_cursor = 3; */
        if (message.idCursor !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.idCursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.PagingInfo
 */
export const PagingInfo = new PagingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryGroupMessagesRequest$Type extends MessageType<QueryGroupMessagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.QueryGroupMessagesRequest", [
            { no: 1, name: "group_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo }
        ]);
    }
    create(value?: PartialMessage<QueryGroupMessagesRequest>): QueryGroupMessagesRequest {
        const message = { groupId: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryGroupMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryGroupMessagesRequest): QueryGroupMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes group_id */ 1:
                    message.groupId = reader.bytes();
                    break;
                case /* xmtp.mls.api.v1.PagingInfo paging_info */ 2:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryGroupMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes group_id = 1; */
        if (message.groupId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.groupId);
        /* xmtp.mls.api.v1.PagingInfo paging_info = 2; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.QueryGroupMessagesRequest
 */
export const QueryGroupMessagesRequest = new QueryGroupMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryGroupMessagesResponse$Type extends MessageType<QueryGroupMessagesResponse> {
    constructor() {
        super("xmtp.mls.api.v1.QueryGroupMessagesResponse", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GroupMessage },
            { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo }
        ]);
    }
    create(value?: PartialMessage<QueryGroupMessagesResponse>): QueryGroupMessagesResponse {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryGroupMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryGroupMessagesResponse): QueryGroupMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.GroupMessage messages */ 1:
                    message.messages.push(GroupMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* xmtp.mls.api.v1.PagingInfo paging_info */ 2:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryGroupMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.GroupMessage messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            GroupMessage.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.mls.api.v1.PagingInfo paging_info = 2; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.QueryGroupMessagesResponse
 */
export const QueryGroupMessagesResponse = new QueryGroupMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryWelcomeMessagesRequest$Type extends MessageType<QueryWelcomeMessagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.QueryWelcomeMessagesRequest", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo }
        ]);
    }
    create(value?: PartialMessage<QueryWelcomeMessagesRequest>): QueryWelcomeMessagesRequest {
        const message = { installationKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryWelcomeMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryWelcomeMessagesRequest): QueryWelcomeMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                case /* xmtp.mls.api.v1.PagingInfo paging_info */ 2:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryWelcomeMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        /* xmtp.mls.api.v1.PagingInfo paging_info = 2; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.QueryWelcomeMessagesRequest
 */
export const QueryWelcomeMessagesRequest = new QueryWelcomeMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class QueryWelcomeMessagesResponse$Type extends MessageType<QueryWelcomeMessagesResponse> {
    constructor() {
        super("xmtp.mls.api.v1.QueryWelcomeMessagesResponse", [
            { no: 1, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WelcomeMessage },
            { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo }
        ]);
    }
    create(value?: PartialMessage<QueryWelcomeMessagesResponse>): QueryWelcomeMessagesResponse {
        const message = { messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<QueryWelcomeMessagesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QueryWelcomeMessagesResponse): QueryWelcomeMessagesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.WelcomeMessage messages */ 1:
                    message.messages.push(WelcomeMessage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* xmtp.mls.api.v1.PagingInfo paging_info */ 2:
                    message.pagingInfo = PagingInfo.internalBinaryRead(reader, reader.uint32(), options, message.pagingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: QueryWelcomeMessagesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.WelcomeMessage messages = 1; */
        for (let i = 0; i < message.messages.length; i++)
            WelcomeMessage.internalBinaryWrite(message.messages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.mls.api.v1.PagingInfo paging_info = 2; */
        if (message.pagingInfo)
            PagingInfo.internalBinaryWrite(message.pagingInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.QueryWelcomeMessagesResponse
 */
export const QueryWelcomeMessagesResponse = new QueryWelcomeMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeGroupMessagesRequest$Type extends MessageType<SubscribeGroupMessagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.SubscribeGroupMessagesRequest", [
            { no: 1, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SubscribeGroupMessagesRequest_Filter }
        ]);
    }
    create(value?: PartialMessage<SubscribeGroupMessagesRequest>): SubscribeGroupMessagesRequest {
        const message = { filters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeGroupMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeGroupMessagesRequest): SubscribeGroupMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.SubscribeGroupMessagesRequest.Filter filters */ 1:
                    message.filters.push(SubscribeGroupMessagesRequest_Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeGroupMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.SubscribeGroupMessagesRequest.Filter filters = 1; */
        for (let i = 0; i < message.filters.length; i++)
            SubscribeGroupMessagesRequest_Filter.internalBinaryWrite(message.filters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.SubscribeGroupMessagesRequest
 */
export const SubscribeGroupMessagesRequest = new SubscribeGroupMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeGroupMessagesRequest_Filter$Type extends MessageType<SubscribeGroupMessagesRequest_Filter> {
    constructor() {
        super("xmtp.mls.api.v1.SubscribeGroupMessagesRequest.Filter", [
            { no: 1, name: "group_id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "id_cursor", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeGroupMessagesRequest_Filter>): SubscribeGroupMessagesRequest_Filter {
        const message = { groupId: new Uint8Array(0), idCursor: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeGroupMessagesRequest_Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeGroupMessagesRequest_Filter): SubscribeGroupMessagesRequest_Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes group_id */ 1:
                    message.groupId = reader.bytes();
                    break;
                case /* uint64 id_cursor */ 2:
                    message.idCursor = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeGroupMessagesRequest_Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes group_id = 1; */
        if (message.groupId.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.groupId);
        /* uint64 id_cursor = 2; */
        if (message.idCursor !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.idCursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.SubscribeGroupMessagesRequest.Filter
 */
export const SubscribeGroupMessagesRequest_Filter = new SubscribeGroupMessagesRequest_Filter$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeWelcomeMessagesRequest$Type extends MessageType<SubscribeWelcomeMessagesRequest> {
    constructor() {
        super("xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest", [
            { no: 1, name: "filters", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SubscribeWelcomeMessagesRequest_Filter }
        ]);
    }
    create(value?: PartialMessage<SubscribeWelcomeMessagesRequest>): SubscribeWelcomeMessagesRequest {
        const message = { filters: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeWelcomeMessagesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeWelcomeMessagesRequest): SubscribeWelcomeMessagesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest.Filter filters */ 1:
                    message.filters.push(SubscribeWelcomeMessagesRequest_Filter.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeWelcomeMessagesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest.Filter filters = 1; */
        for (let i = 0; i < message.filters.length; i++)
            SubscribeWelcomeMessagesRequest_Filter.internalBinaryWrite(message.filters[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest
 */
export const SubscribeWelcomeMessagesRequest = new SubscribeWelcomeMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeWelcomeMessagesRequest_Filter$Type extends MessageType<SubscribeWelcomeMessagesRequest_Filter> {
    constructor() {
        super("xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest.Filter", [
            { no: 1, name: "installation_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "id_cursor", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SubscribeWelcomeMessagesRequest_Filter>): SubscribeWelcomeMessagesRequest_Filter {
        const message = { installationKey: new Uint8Array(0), idCursor: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SubscribeWelcomeMessagesRequest_Filter>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubscribeWelcomeMessagesRequest_Filter): SubscribeWelcomeMessagesRequest_Filter {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes installation_key */ 1:
                    message.installationKey = reader.bytes();
                    break;
                case /* uint64 id_cursor */ 2:
                    message.idCursor = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubscribeWelcomeMessagesRequest_Filter, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes installation_key = 1; */
        if (message.installationKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.installationKey);
        /* uint64 id_cursor = 2; */
        if (message.idCursor !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.idCursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.mls.api.v1.SubscribeWelcomeMessagesRequest.Filter
 */
export const SubscribeWelcomeMessagesRequest_Filter = new SubscribeWelcomeMessagesRequest_Filter$Type();
/**
 * @generated ServiceType for protobuf service xmtp.mls.api.v1.MlsApi
 */
export const MlsApi = new ServiceType("xmtp.mls.api.v1.MlsApi", [
    { name: "SendGroupMessages", options: { "google.api.http": { post: "/mls/v1/send-group-messages", body: "*" } }, I: SendGroupMessagesRequest, O: Empty },
    { name: "SendWelcomeMessages", options: { "google.api.http": { post: "/mls/v1/send-welcome-messages", body: "*" } }, I: SendWelcomeMessagesRequest, O: Empty },
    { name: "RegisterInstallation", options: { "google.api.http": { post: "/mls/v1/register-installation", body: "*" } }, I: RegisterInstallationRequest, O: RegisterInstallationResponse },
    { name: "UploadKeyPackage", options: { "google.api.http": { post: "/mls/v1/upload-key-package", body: "*" } }, I: UploadKeyPackageRequest, O: Empty },
    { name: "FetchKeyPackages", options: { "google.api.http": { post: "/mls/v1/fetch-key-packages", body: "*" } }, I: FetchKeyPackagesRequest, O: FetchKeyPackagesResponse },
    { name: "RevokeInstallation", options: { "google.api.http": { post: "/mls/v1/revoke-installation", body: "*" } }, I: RevokeInstallationRequest, O: Empty },
    { name: "GetIdentityUpdates", options: { "google.api.http": { post: "/mls/v1/get-identity-updates", body: "*" } }, I: GetIdentityUpdatesRequest, O: GetIdentityUpdatesResponse },
    { name: "QueryGroupMessages", options: { "google.api.http": { post: "/mls/v1/query-group-messages", body: "*" } }, I: QueryGroupMessagesRequest, O: QueryGroupMessagesResponse },
    { name: "QueryWelcomeMessages", options: { "google.api.http": { post: "/mls/v1/query-welcome-messages", body: "*" } }, I: QueryWelcomeMessagesRequest, O: QueryWelcomeMessagesResponse },
    { name: "SubscribeGroupMessages", serverStreaming: true, options: { "google.api.http": { post: "/mls/v1/subscribe-group-messages", body: "*" } }, I: SubscribeGroupMessagesRequest, O: GroupMessage },
    { name: "SubscribeWelcomeMessages", serverStreaming: true, options: { "google.api.http": { post: "/mls/v1/subscribe-welcome-messages", body: "*" } }, I: SubscribeWelcomeMessagesRequest, O: WelcomeMessage }
]);
