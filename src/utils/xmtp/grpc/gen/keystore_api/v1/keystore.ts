// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "keystore_api/v1/keystore.proto" (package "xmtp.keystore_api.v1", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { InvitationV1 } from "../../message_contents/invitation";
import { PrivateKeyBundleV1 } from "../../message_contents/private_key";
import { ConversationReference } from "../../message_contents/conversation_reference";
import { SignedPublicKeyBundle } from "../../message_contents/public_key";
import { InvitationV1_Context } from "../../message_contents/invitation";
import { PublicKeyBundle } from "../../message_contents/public_key";
import { Ciphertext } from "../../message_contents/ciphertext";
/**
 * Wrapper class for errors from the Keystore API
 *
 * @generated from protobuf message xmtp.keystore_api.v1.KeystoreError
 */
export interface KeystoreError {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: xmtp.keystore_api.v1.ErrorCode code = 2;
     */
    code: ErrorCode;
}
/**
 * Decrypt a batch of messages using X3DH key agreement
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptV1Request
 */
export interface DecryptV1Request {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.DecryptV1Request.Request requests = 1;
     */
    requests: DecryptV1Request_Request[];
}
/**
 * A single decryption request
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptV1Request.Request
 */
export interface DecryptV1Request_Request {
    /**
     * @generated from protobuf field: xmtp.message_contents.Ciphertext payload = 1;
     */
    payload?: Ciphertext;
    /**
     * @generated from protobuf field: xmtp.message_contents.PublicKeyBundle peer_keys = 2;
     */
    peerKeys?: PublicKeyBundle;
    /**
     * @generated from protobuf field: bytes header_bytes = 3;
     */
    headerBytes: Uint8Array;
    /**
     * @generated from protobuf field: bool is_sender = 4;
     */
    isSender: boolean;
}
/**
 * Response type for both V1 and V2 decryption requests
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptResponse
 */
export interface DecryptResponse {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.DecryptResponse.Response responses = 1;
     */
    responses: DecryptResponse_Response[];
}
/**
 * A single decryption response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptResponse.Response
 */
export interface DecryptResponse_Response {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "result";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.DecryptResponse.Response.Success result = 1;
         */
        result: DecryptResponse_Response_Success;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.KeystoreError error = 2;
         */
        error: KeystoreError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Wrapper object for success response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptResponse.Response.Success
 */
export interface DecryptResponse_Response_Success {
    /**
     * @generated from protobuf field: bytes decrypted = 1;
     */
    decrypted: Uint8Array;
}
/**
 * Decrypt a batch of messages using the appropriate topic keys
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptV2Request
 */
export interface DecryptV2Request {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.DecryptV2Request.Request requests = 1;
     */
    requests: DecryptV2Request_Request[];
}
/**
 * A single decryption request
 *
 * @generated from protobuf message xmtp.keystore_api.v1.DecryptV2Request.Request
 */
export interface DecryptV2Request_Request {
    /**
     * @generated from protobuf field: xmtp.message_contents.Ciphertext payload = 1;
     */
    payload?: Ciphertext;
    /**
     * @generated from protobuf field: bytes header_bytes = 2;
     */
    headerBytes: Uint8Array;
    /**
     * @generated from protobuf field: string content_topic = 3;
     */
    contentTopic: string;
}
/**
 * Encrypt a batch of messages using X3DH key agreement
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptV1Request
 */
export interface EncryptV1Request {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.EncryptV1Request.Request requests = 1;
     */
    requests: EncryptV1Request_Request[];
}
/**
 * A single encryption request
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptV1Request.Request
 */
export interface EncryptV1Request_Request {
    /**
     * @generated from protobuf field: xmtp.message_contents.PublicKeyBundle recipient = 1;
     */
    recipient?: PublicKeyBundle;
    /**
     * @generated from protobuf field: bytes payload = 2;
     */
    payload: Uint8Array;
    /**
     * @generated from protobuf field: bytes header_bytes = 3;
     */
    headerBytes: Uint8Array;
}
/**
 * Response type for both V1 and V2 encryption requests
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptResponse
 */
export interface EncryptResponse {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.EncryptResponse.Response responses = 1;
     */
    responses: EncryptResponse_Response[];
}
/**
 * A single encryption response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptResponse.Response
 */
export interface EncryptResponse_Response {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "result";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.EncryptResponse.Response.Success result = 1;
         */
        result: EncryptResponse_Response_Success;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.KeystoreError error = 2;
         */
        error: KeystoreError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Wrapper object for success response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptResponse.Response.Success
 */
export interface EncryptResponse_Response_Success {
    /**
     * @generated from protobuf field: xmtp.message_contents.Ciphertext encrypted = 1;
     */
    encrypted?: Ciphertext;
    /**
     * @generated from protobuf field: bytes sender_hmac = 2;
     */
    senderHmac: Uint8Array;
}
/**
 * Encrypt a batch of messages using the appropriate topic keys
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptV2Request
 */
export interface EncryptV2Request {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.EncryptV2Request.Request requests = 1;
     */
    requests: EncryptV2Request_Request[];
}
/**
 * A single encryption request
 *
 * @generated from protobuf message xmtp.keystore_api.v1.EncryptV2Request.Request
 */
export interface EncryptV2Request_Request {
    /**
     * @generated from protobuf field: bytes payload = 1;
     */
    payload: Uint8Array;
    /**
     * @generated from protobuf field: bytes header_bytes = 2;
     */
    headerBytes: Uint8Array;
    /**
     * @generated from protobuf field: string content_topic = 3;
     */
    contentTopic: string;
}
/**
 * Encrypt a message for yourself
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfEncryptRequest
 */
export interface SelfEncryptRequest {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.SelfEncryptRequest.Request requests = 1;
     */
    requests: SelfEncryptRequest_Request[];
}
/**
 * Request type
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfEncryptRequest.Request
 */
export interface SelfEncryptRequest_Request {
    /**
     * @generated from protobuf field: bytes payload = 1;
     */
    payload: Uint8Array;
}
/**
 * Response type for SelfEncryptRequest
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfEncryptResponse
 */
export interface SelfEncryptResponse {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.SelfEncryptResponse.Response responses = 1;
     */
    responses: SelfEncryptResponse_Response[];
}
/**
 * Response type
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfEncryptResponse.Response
 */
export interface SelfEncryptResponse_Response {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "result";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success result = 1;
         */
        result: SelfEncryptResponse_Response_Success;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.KeystoreError error = 2;
         */
        error: KeystoreError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Success response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success
 */
export interface SelfEncryptResponse_Response_Success {
    /**
     * @generated from protobuf field: bytes encrypted = 1;
     */
    encrypted: Uint8Array;
}
/**
 * SelfDecryptRequest
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfDecryptRequest
 */
export interface SelfDecryptRequest {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.SelfDecryptRequest.Request requests = 1;
     */
    requests: SelfDecryptRequest_Request[];
}
/**
 * Request type
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SelfDecryptRequest.Request
 */
export interface SelfDecryptRequest_Request {
    /**
     * @generated from protobuf field: bytes payload = 1;
     */
    payload: Uint8Array;
}
/**
 * Get the private preferences topic identifier
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetPrivatePreferencesTopicIdentifierResponse
 */
export interface GetPrivatePreferencesTopicIdentifierResponse {
    /**
     * @generated from protobuf field: string identifier = 1;
     */
    identifier: string;
}
/**
 * Request to create an invite payload, and store the topic keys in the Keystore
 *
 * @generated from protobuf message xmtp.keystore_api.v1.CreateInviteRequest
 */
export interface CreateInviteRequest {
    /**
     * @generated from protobuf field: xmtp.message_contents.InvitationV1.Context context = 1;
     */
    context?: InvitationV1_Context;
    /**
     * @generated from protobuf field: xmtp.message_contents.SignedPublicKeyBundle recipient = 2;
     */
    recipient?: SignedPublicKeyBundle;
    /**
     * @generated from protobuf field: uint64 created_ns = 3;
     */
    createdNs: bigint;
}
/**
 * Response to a CreateInviteRequest
 *
 * @generated from protobuf message xmtp.keystore_api.v1.CreateInviteResponse
 */
export interface CreateInviteResponse {
    /**
     * @generated from protobuf field: xmtp.message_contents.ConversationReference conversation = 1;
     */
    conversation?: ConversationReference;
    /**
     * @generated from protobuf field: bytes payload = 2;
     */
    payload: Uint8Array;
}
/**
 * Request to save a batch of invite messages to the Keystore
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveInvitesRequest
 */
export interface SaveInvitesRequest {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.SaveInvitesRequest.Request requests = 1;
     */
    requests: SaveInvitesRequest_Request[];
}
/**
 * Mirrors xmtp.envelope schema
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveInvitesRequest.Request
 */
export interface SaveInvitesRequest_Request {
    /**
     * @generated from protobuf field: string content_topic = 1;
     */
    contentTopic: string;
    /**
     * @generated from protobuf field: uint64 timestamp_ns = 2;
     */
    timestampNs: bigint;
    /**
     * @generated from protobuf field: bytes payload = 3;
     */
    payload: Uint8Array;
}
/**
 * Response to a SaveInvitesRequest
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveInvitesResponse
 */
export interface SaveInvitesResponse {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.SaveInvitesResponse.Response responses = 1;
     */
    responses: SaveInvitesResponse_Response[];
}
/**
 * A single response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveInvitesResponse.Response
 */
export interface SaveInvitesResponse_Response {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "result";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success result = 1;
         */
        result: SaveInvitesResponse_Response_Success;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: xmtp.keystore_api.v1.KeystoreError error = 2;
         */
        error: KeystoreError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Wrapper object for success response
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success
 */
export interface SaveInvitesResponse_Response_Success {
    /**
     * @generated from protobuf field: xmtp.message_contents.ConversationReference conversation = 1;
     */
    conversation?: ConversationReference;
}
/**
 * CreateAuthTokenRequest is used to create an auth token for the XMTP API
 *
 * @generated from protobuf message xmtp.keystore_api.v1.CreateAuthTokenRequest
 */
export interface CreateAuthTokenRequest {
    /**
     * @generated from protobuf field: optional uint64 timestamp_ns = 1;
     */
    timestampNs?: bigint;
}
/**
 * SaveV1ConversationsRequest is used to save a batch of conversations to the
 * built in persistence
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveV1ConversationsRequest
 */
export interface SaveV1ConversationsRequest {
    /**
     * @generated from protobuf field: repeated xmtp.message_contents.ConversationReference conversations = 1;
     */
    conversations: ConversationReference[];
}
/**
 * Placeholder response type for SaveV1Conversations
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SaveV1ConversationsResponse
 */
export interface SaveV1ConversationsResponse {
}
/**
 * Response for GetV2Conversations
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetConversationsResponse
 */
export interface GetConversationsResponse {
    /**
     * @generated from protobuf field: repeated xmtp.message_contents.ConversationReference conversations = 1;
     */
    conversations: ConversationReference[];
}
/**
 * Used to check if the Keystore implementation has been setup for the given
 * wallet address Only used for MM Snap Keystore currently
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetKeystoreStatusRequest
 */
export interface GetKeystoreStatusRequest {
    /**
     * @generated from protobuf field: string wallet_address = 1;
     */
    walletAddress: string;
}
/**
 * Response to GetKeystoreStatusRequest
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetKeystoreStatusResponse
 */
export interface GetKeystoreStatusResponse {
    /**
     * @generated from protobuf field: xmtp.keystore_api.v1.GetKeystoreStatusResponse.KeystoreStatus status = 1;
     */
    status: GetKeystoreStatusResponse_KeystoreStatus;
}
/**
 * Status of the Keystore for the specified wallet address
 *
 * @generated from protobuf enum xmtp.keystore_api.v1.GetKeystoreStatusResponse.KeystoreStatus
 */
export enum GetKeystoreStatusResponse_KeystoreStatus {
    /**
     * @generated from protobuf enum value: KEYSTORE_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: KEYSTORE_STATUS_UNINITIALIZED = 1;
     */
    UNINITIALIZED = 1,
    /**
     * @generated from protobuf enum value: KEYSTORE_STATUS_INITIALIZED = 2;
     */
    INITIALIZED = 2
}
/**
 * Used to initialize the Keystore with a private key bundle retrieved from the
 * client
 *
 * @generated from protobuf message xmtp.keystore_api.v1.InitKeystoreRequest
 */
export interface InitKeystoreRequest {
    /**
     * @generated from protobuf oneof: bundle
     */
    bundle: {
        oneofKind: "v1";
        /**
         * @generated from protobuf field: xmtp.message_contents.PrivateKeyBundleV1 v1 = 1;
         */
        v1: PrivateKeyBundleV1;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Response to the request to initialize the Keystore
 *
 * @generated from protobuf message xmtp.keystore_api.v1.InitKeystoreResponse
 */
export interface InitKeystoreResponse {
    /**
     * @generated from protobuf field: xmtp.keystore_api.v1.KeystoreError error = 1;
     */
    error?: KeystoreError;
}
/**
 * SignDigestRequest is used to sign a digest with either the identity key
 * or a prekey
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SignDigestRequest
 */
export interface SignDigestRequest {
    /**
     * @generated from protobuf field: bytes digest = 1;
     */
    digest: Uint8Array;
    /**
     * @generated from protobuf oneof: signer
     */
    signer: {
        oneofKind: "identityKey";
        /**
         * @generated from protobuf field: bool identity_key = 2;
         */
        identityKey: boolean;
    } | {
        oneofKind: "prekeyIndex";
        /**
         * @generated from protobuf field: uint32 prekey_index = 3;
         */
        prekeyIndex: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * GetRefreshJobRequest is used to get the last run time of a refresh job
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetRefreshJobRequest
 */
export interface GetRefreshJobRequest {
    /**
     * @generated from protobuf field: xmtp.keystore_api.v1.JobType job_type = 1;
     */
    jobType: JobType;
}
/**
 * GetRefreshJobResponse is used to return the last run time of a refresh job
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetRefreshJobResponse
 */
export interface GetRefreshJobResponse {
    /**
     * @generated from protobuf field: int64 last_run_ns = 1;
     */
    lastRunNs: bigint;
}
/**
 * SetRefreshJobRequest is used to set the last run time of a refresh job
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SetRefeshJobRequest
 */
export interface SetRefeshJobRequest {
    /**
     * @generated from protobuf field: xmtp.keystore_api.v1.JobType job_type = 1;
     */
    jobType: JobType;
    /**
     * @generated from protobuf field: int64 last_run_ns = 2;
     */
    lastRunNs: bigint;
}
/**
 * SetRefreshJobResponse is an empty response type
 *
 * @generated from protobuf message xmtp.keystore_api.v1.SetRefreshJobResponse
 */
export interface SetRefreshJobResponse {
}
/**
 * A mapping of topics to their decrypted invitations
 *
 * @generated from protobuf message xmtp.keystore_api.v1.TopicMap
 */
export interface TopicMap {
    /**
     * @generated from protobuf field: map<string, xmtp.keystore_api.v1.TopicMap.TopicData> topics = 1;
     */
    topics: {
        [key: string]: TopicMap_TopicData;
    };
}
/**
 * TopicData wraps the invitation and the timestamp it was created
 *
 * @generated from protobuf message xmtp.keystore_api.v1.TopicMap.TopicData
 */
export interface TopicMap_TopicData {
    /**
     * @generated from protobuf field: uint64 created_ns = 1;
     */
    createdNs: bigint;
    /**
     * @generated from protobuf field: string peer_address = 2;
     */
    peerAddress: string;
    /**
     * @generated from protobuf field: xmtp.message_contents.InvitationV1 invitation = 3;
     */
    invitation?: InvitationV1;
}
/**
 * Used to get a mapping of conversation topics to their HMAC keys
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysRequest
 */
export interface GetConversationHmacKeysRequest {
    /**
     * @generated from protobuf field: repeated string topics = 1;
     */
    topics: string[];
}
/**
 * A mapping of topics to their HMAC keys
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysResponse
 */
export interface GetConversationHmacKeysResponse {
    /**
     * @generated from protobuf field: map<string, xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys> hmac_keys = 1;
     */
    hmacKeys: {
        [key: string]: GetConversationHmacKeysResponse_HmacKeys;
    };
}
/**
 * HmacKeyData wraps the HMAC key and the number of 30 day periods since epoch
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData
 */
export interface GetConversationHmacKeysResponse_HmacKeyData {
    /**
     * @generated from protobuf field: int32 thirty_day_periods_since_epoch = 1;
     */
    thirtyDayPeriodsSinceEpoch: number;
    /**
     * @generated from protobuf field: bytes hmac_key = 2;
     */
    hmacKey: Uint8Array;
}
/**
 * HmacKeys represents multiple HmacKeyData objects
 *
 * @generated from protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys
 */
export interface GetConversationHmacKeysResponse_HmacKeys {
    /**
     * @generated from protobuf field: repeated xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData values = 1;
     */
    values: GetConversationHmacKeysResponse_HmacKeyData[];
}
/**
 * Application-specific error codes for the Keystore API.
 *
 * @generated from protobuf enum xmtp.keystore_api.v1.ErrorCode
 */
export enum ErrorCode {
    /**
     * @generated from protobuf enum value: ERROR_CODE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ERROR_CODE_INVALID_INPUT = 1;
     */
    INVALID_INPUT = 1,
    /**
     * @generated from protobuf enum value: ERROR_CODE_NO_MATCHING_PREKEY = 2;
     */
    NO_MATCHING_PREKEY = 2
}
/**
 * JobType is used to specify the type of job the caller would like info on
 *
 * @generated from protobuf enum xmtp.keystore_api.v1.JobType
 */
export enum JobType {
    /**
     * @generated from protobuf enum value: JOB_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: JOB_TYPE_REFRESH_V1 = 1;
     */
    REFRESH_V1 = 1,
    /**
     * @generated from protobuf enum value: JOB_TYPE_REFRESH_V2 = 2;
     */
    REFRESH_V2 = 2,
    /**
     * @generated from protobuf enum value: JOB_TYPE_REFRESH_PPPP = 3;
     */
    REFRESH_PPPP = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class KeystoreError$Type extends MessageType<KeystoreError> {
    constructor() {
        super("xmtp.keystore_api.v1.KeystoreError", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "enum", T: () => ["xmtp.keystore_api.v1.ErrorCode", ErrorCode, "ERROR_CODE_"] }
        ]);
    }
    create(value?: PartialMessage<KeystoreError>): KeystoreError {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<KeystoreError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeystoreError): KeystoreError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* xmtp.keystore_api.v1.ErrorCode code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeystoreError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* xmtp.keystore_api.v1.ErrorCode code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.KeystoreError
 */
export const KeystoreError = new KeystoreError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptV1Request$Type extends MessageType<DecryptV1Request> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptV1Request", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DecryptV1Request_Request }
        ]);
    }
    create(value?: PartialMessage<DecryptV1Request>): DecryptV1Request {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptV1Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptV1Request): DecryptV1Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.DecryptV1Request.Request requests */ 1:
                    message.requests.push(DecryptV1Request_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptV1Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.DecryptV1Request.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            DecryptV1Request_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptV1Request
 */
export const DecryptV1Request = new DecryptV1Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptV1Request_Request$Type extends MessageType<DecryptV1Request_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptV1Request.Request", [
            { no: 1, name: "payload", kind: "message", T: () => Ciphertext },
            { no: 2, name: "peer_keys", kind: "message", T: () => PublicKeyBundle },
            { no: 3, name: "header_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "is_sender", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DecryptV1Request_Request>): DecryptV1Request_Request {
        const message = { headerBytes: new Uint8Array(0), isSender: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptV1Request_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptV1Request_Request): DecryptV1Request_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.Ciphertext payload */ 1:
                    message.payload = Ciphertext.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* xmtp.message_contents.PublicKeyBundle peer_keys */ 2:
                    message.peerKeys = PublicKeyBundle.internalBinaryRead(reader, reader.uint32(), options, message.peerKeys);
                    break;
                case /* bytes header_bytes */ 3:
                    message.headerBytes = reader.bytes();
                    break;
                case /* bool is_sender */ 4:
                    message.isSender = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptV1Request_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.Ciphertext payload = 1; */
        if (message.payload)
            Ciphertext.internalBinaryWrite(message.payload, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_contents.PublicKeyBundle peer_keys = 2; */
        if (message.peerKeys)
            PublicKeyBundle.internalBinaryWrite(message.peerKeys, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bytes header_bytes = 3; */
        if (message.headerBytes.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.headerBytes);
        /* bool is_sender = 4; */
        if (message.isSender !== false)
            writer.tag(4, WireType.Varint).bool(message.isSender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptV1Request.Request
 */
export const DecryptV1Request_Request = new DecryptV1Request_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptResponse$Type extends MessageType<DecryptResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DecryptResponse_Response }
        ]);
    }
    create(value?: PartialMessage<DecryptResponse>): DecryptResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptResponse): DecryptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.DecryptResponse.Response responses */ 1:
                    message.responses.push(DecryptResponse_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.DecryptResponse.Response responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            DecryptResponse_Response.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptResponse
 */
export const DecryptResponse = new DecryptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptResponse_Response$Type extends MessageType<DecryptResponse_Response> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptResponse.Response", [
            { no: 1, name: "result", kind: "message", oneof: "response", T: () => DecryptResponse_Response_Success },
            { no: 2, name: "error", kind: "message", oneof: "response", T: () => KeystoreError }
        ]);
    }
    create(value?: PartialMessage<DecryptResponse_Response>): DecryptResponse_Response {
        const message = { response: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptResponse_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptResponse_Response): DecryptResponse_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.DecryptResponse.Response.Success result */ 1:
                    message.response = {
                        oneofKind: "result",
                        result: DecryptResponse_Response_Success.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).result)
                    };
                    break;
                case /* xmtp.keystore_api.v1.KeystoreError error */ 2:
                    message.response = {
                        oneofKind: "error",
                        error: KeystoreError.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptResponse_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.DecryptResponse.Response.Success result = 1; */
        if (message.response.oneofKind === "result")
            DecryptResponse_Response_Success.internalBinaryWrite(message.response.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.keystore_api.v1.KeystoreError error = 2; */
        if (message.response.oneofKind === "error")
            KeystoreError.internalBinaryWrite(message.response.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptResponse.Response
 */
export const DecryptResponse_Response = new DecryptResponse_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptResponse_Response_Success$Type extends MessageType<DecryptResponse_Response_Success> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptResponse.Response.Success", [
            { no: 1, name: "decrypted", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DecryptResponse_Response_Success>): DecryptResponse_Response_Success {
        const message = { decrypted: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptResponse_Response_Success>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptResponse_Response_Success): DecryptResponse_Response_Success {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes decrypted */ 1:
                    message.decrypted = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptResponse_Response_Success, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes decrypted = 1; */
        if (message.decrypted.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.decrypted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptResponse.Response.Success
 */
export const DecryptResponse_Response_Success = new DecryptResponse_Response_Success$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptV2Request$Type extends MessageType<DecryptV2Request> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptV2Request", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DecryptV2Request_Request }
        ]);
    }
    create(value?: PartialMessage<DecryptV2Request>): DecryptV2Request {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptV2Request): DecryptV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.DecryptV2Request.Request requests */ 1:
                    message.requests.push(DecryptV2Request_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.DecryptV2Request.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            DecryptV2Request_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptV2Request
 */
export const DecryptV2Request = new DecryptV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DecryptV2Request_Request$Type extends MessageType<DecryptV2Request_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.DecryptV2Request.Request", [
            { no: 1, name: "payload", kind: "message", T: () => Ciphertext },
            { no: 2, name: "header_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "content_topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DecryptV2Request_Request>): DecryptV2Request_Request {
        const message = { headerBytes: new Uint8Array(0), contentTopic: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DecryptV2Request_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DecryptV2Request_Request): DecryptV2Request_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.Ciphertext payload */ 1:
                    message.payload = Ciphertext.internalBinaryRead(reader, reader.uint32(), options, message.payload);
                    break;
                case /* bytes header_bytes */ 2:
                    message.headerBytes = reader.bytes();
                    break;
                case /* string content_topic */ 3:
                    message.contentTopic = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DecryptV2Request_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.Ciphertext payload = 1; */
        if (message.payload)
            Ciphertext.internalBinaryWrite(message.payload, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes header_bytes = 2; */
        if (message.headerBytes.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.headerBytes);
        /* string content_topic = 3; */
        if (message.contentTopic !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contentTopic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.DecryptV2Request.Request
 */
export const DecryptV2Request_Request = new DecryptV2Request_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptV1Request$Type extends MessageType<EncryptV1Request> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptV1Request", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EncryptV1Request_Request }
        ]);
    }
    create(value?: PartialMessage<EncryptV1Request>): EncryptV1Request {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptV1Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptV1Request): EncryptV1Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.EncryptV1Request.Request requests */ 1:
                    message.requests.push(EncryptV1Request_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptV1Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.EncryptV1Request.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            EncryptV1Request_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptV1Request
 */
export const EncryptV1Request = new EncryptV1Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptV1Request_Request$Type extends MessageType<EncryptV1Request_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptV1Request.Request", [
            { no: 1, name: "recipient", kind: "message", T: () => PublicKeyBundle },
            { no: 2, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "header_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<EncryptV1Request_Request>): EncryptV1Request_Request {
        const message = { payload: new Uint8Array(0), headerBytes: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptV1Request_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptV1Request_Request): EncryptV1Request_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.PublicKeyBundle recipient */ 1:
                    message.recipient = PublicKeyBundle.internalBinaryRead(reader, reader.uint32(), options, message.recipient);
                    break;
                case /* bytes payload */ 2:
                    message.payload = reader.bytes();
                    break;
                case /* bytes header_bytes */ 3:
                    message.headerBytes = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptV1Request_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.PublicKeyBundle recipient = 1; */
        if (message.recipient)
            PublicKeyBundle.internalBinaryWrite(message.recipient, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes payload = 2; */
        if (message.payload.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
        /* bytes header_bytes = 3; */
        if (message.headerBytes.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.headerBytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptV1Request.Request
 */
export const EncryptV1Request_Request = new EncryptV1Request_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptResponse$Type extends MessageType<EncryptResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EncryptResponse_Response }
        ]);
    }
    create(value?: PartialMessage<EncryptResponse>): EncryptResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptResponse): EncryptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.EncryptResponse.Response responses */ 1:
                    message.responses.push(EncryptResponse_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.EncryptResponse.Response responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            EncryptResponse_Response.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptResponse
 */
export const EncryptResponse = new EncryptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptResponse_Response$Type extends MessageType<EncryptResponse_Response> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptResponse.Response", [
            { no: 1, name: "result", kind: "message", oneof: "response", T: () => EncryptResponse_Response_Success },
            { no: 2, name: "error", kind: "message", oneof: "response", T: () => KeystoreError }
        ]);
    }
    create(value?: PartialMessage<EncryptResponse_Response>): EncryptResponse_Response {
        const message = { response: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptResponse_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptResponse_Response): EncryptResponse_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.EncryptResponse.Response.Success result */ 1:
                    message.response = {
                        oneofKind: "result",
                        result: EncryptResponse_Response_Success.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).result)
                    };
                    break;
                case /* xmtp.keystore_api.v1.KeystoreError error */ 2:
                    message.response = {
                        oneofKind: "error",
                        error: KeystoreError.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptResponse_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.EncryptResponse.Response.Success result = 1; */
        if (message.response.oneofKind === "result")
            EncryptResponse_Response_Success.internalBinaryWrite(message.response.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.keystore_api.v1.KeystoreError error = 2; */
        if (message.response.oneofKind === "error")
            KeystoreError.internalBinaryWrite(message.response.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptResponse.Response
 */
export const EncryptResponse_Response = new EncryptResponse_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptResponse_Response_Success$Type extends MessageType<EncryptResponse_Response_Success> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptResponse.Response.Success", [
            { no: 1, name: "encrypted", kind: "message", T: () => Ciphertext },
            { no: 2, name: "sender_hmac", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<EncryptResponse_Response_Success>): EncryptResponse_Response_Success {
        const message = { senderHmac: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptResponse_Response_Success>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptResponse_Response_Success): EncryptResponse_Response_Success {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.Ciphertext encrypted */ 1:
                    message.encrypted = Ciphertext.internalBinaryRead(reader, reader.uint32(), options, message.encrypted);
                    break;
                case /* bytes sender_hmac */ 2:
                    message.senderHmac = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptResponse_Response_Success, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.Ciphertext encrypted = 1; */
        if (message.encrypted)
            Ciphertext.internalBinaryWrite(message.encrypted, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes sender_hmac = 2; */
        if (message.senderHmac.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.senderHmac);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptResponse.Response.Success
 */
export const EncryptResponse_Response_Success = new EncryptResponse_Response_Success$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptV2Request$Type extends MessageType<EncryptV2Request> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptV2Request", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => EncryptV2Request_Request }
        ]);
    }
    create(value?: PartialMessage<EncryptV2Request>): EncryptV2Request {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptV2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptV2Request): EncryptV2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.EncryptV2Request.Request requests */ 1:
                    message.requests.push(EncryptV2Request_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptV2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.EncryptV2Request.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            EncryptV2Request_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptV2Request
 */
export const EncryptV2Request = new EncryptV2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncryptV2Request_Request$Type extends MessageType<EncryptV2Request_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.EncryptV2Request.Request", [
            { no: 1, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "header_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "content_topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EncryptV2Request_Request>): EncryptV2Request_Request {
        const message = { payload: new Uint8Array(0), headerBytes: new Uint8Array(0), contentTopic: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EncryptV2Request_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncryptV2Request_Request): EncryptV2Request_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payload */ 1:
                    message.payload = reader.bytes();
                    break;
                case /* bytes header_bytes */ 2:
                    message.headerBytes = reader.bytes();
                    break;
                case /* string content_topic */ 3:
                    message.contentTopic = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncryptV2Request_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payload = 1; */
        if (message.payload.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.payload);
        /* bytes header_bytes = 2; */
        if (message.headerBytes.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.headerBytes);
        /* string content_topic = 3; */
        if (message.contentTopic !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.contentTopic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.EncryptV2Request.Request
 */
export const EncryptV2Request_Request = new EncryptV2Request_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfEncryptRequest$Type extends MessageType<SelfEncryptRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfEncryptRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SelfEncryptRequest_Request }
        ]);
    }
    create(value?: PartialMessage<SelfEncryptRequest>): SelfEncryptRequest {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfEncryptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfEncryptRequest): SelfEncryptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.SelfEncryptRequest.Request requests */ 1:
                    message.requests.push(SelfEncryptRequest_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfEncryptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.SelfEncryptRequest.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            SelfEncryptRequest_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfEncryptRequest
 */
export const SelfEncryptRequest = new SelfEncryptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfEncryptRequest_Request$Type extends MessageType<SelfEncryptRequest_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfEncryptRequest.Request", [
            { no: 1, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SelfEncryptRequest_Request>): SelfEncryptRequest_Request {
        const message = { payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfEncryptRequest_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfEncryptRequest_Request): SelfEncryptRequest_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payload */ 1:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfEncryptRequest_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payload = 1; */
        if (message.payload.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfEncryptRequest.Request
 */
export const SelfEncryptRequest_Request = new SelfEncryptRequest_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfEncryptResponse$Type extends MessageType<SelfEncryptResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfEncryptResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SelfEncryptResponse_Response }
        ]);
    }
    create(value?: PartialMessage<SelfEncryptResponse>): SelfEncryptResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfEncryptResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfEncryptResponse): SelfEncryptResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.SelfEncryptResponse.Response responses */ 1:
                    message.responses.push(SelfEncryptResponse_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfEncryptResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.SelfEncryptResponse.Response responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            SelfEncryptResponse_Response.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfEncryptResponse
 */
export const SelfEncryptResponse = new SelfEncryptResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfEncryptResponse_Response$Type extends MessageType<SelfEncryptResponse_Response> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfEncryptResponse.Response", [
            { no: 1, name: "result", kind: "message", oneof: "response", T: () => SelfEncryptResponse_Response_Success },
            { no: 2, name: "error", kind: "message", oneof: "response", T: () => KeystoreError }
        ]);
    }
    create(value?: PartialMessage<SelfEncryptResponse_Response>): SelfEncryptResponse_Response {
        const message = { response: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfEncryptResponse_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfEncryptResponse_Response): SelfEncryptResponse_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success result */ 1:
                    message.response = {
                        oneofKind: "result",
                        result: SelfEncryptResponse_Response_Success.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).result)
                    };
                    break;
                case /* xmtp.keystore_api.v1.KeystoreError error */ 2:
                    message.response = {
                        oneofKind: "error",
                        error: KeystoreError.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfEncryptResponse_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success result = 1; */
        if (message.response.oneofKind === "result")
            SelfEncryptResponse_Response_Success.internalBinaryWrite(message.response.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.keystore_api.v1.KeystoreError error = 2; */
        if (message.response.oneofKind === "error")
            KeystoreError.internalBinaryWrite(message.response.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfEncryptResponse.Response
 */
export const SelfEncryptResponse_Response = new SelfEncryptResponse_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfEncryptResponse_Response_Success$Type extends MessageType<SelfEncryptResponse_Response_Success> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success", [
            { no: 1, name: "encrypted", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SelfEncryptResponse_Response_Success>): SelfEncryptResponse_Response_Success {
        const message = { encrypted: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfEncryptResponse_Response_Success>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfEncryptResponse_Response_Success): SelfEncryptResponse_Response_Success {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes encrypted */ 1:
                    message.encrypted = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfEncryptResponse_Response_Success, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes encrypted = 1; */
        if (message.encrypted.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.encrypted);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfEncryptResponse.Response.Success
 */
export const SelfEncryptResponse_Response_Success = new SelfEncryptResponse_Response_Success$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfDecryptRequest$Type extends MessageType<SelfDecryptRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfDecryptRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SelfDecryptRequest_Request }
        ]);
    }
    create(value?: PartialMessage<SelfDecryptRequest>): SelfDecryptRequest {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfDecryptRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfDecryptRequest): SelfDecryptRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.SelfDecryptRequest.Request requests */ 1:
                    message.requests.push(SelfDecryptRequest_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfDecryptRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.SelfDecryptRequest.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            SelfDecryptRequest_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfDecryptRequest
 */
export const SelfDecryptRequest = new SelfDecryptRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SelfDecryptRequest_Request$Type extends MessageType<SelfDecryptRequest_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.SelfDecryptRequest.Request", [
            { no: 1, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SelfDecryptRequest_Request>): SelfDecryptRequest_Request {
        const message = { payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SelfDecryptRequest_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SelfDecryptRequest_Request): SelfDecryptRequest_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes payload */ 1:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SelfDecryptRequest_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes payload = 1; */
        if (message.payload.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SelfDecryptRequest.Request
 */
export const SelfDecryptRequest_Request = new SelfDecryptRequest_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPrivatePreferencesTopicIdentifierResponse$Type extends MessageType<GetPrivatePreferencesTopicIdentifierResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.GetPrivatePreferencesTopicIdentifierResponse", [
            { no: 1, name: "identifier", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPrivatePreferencesTopicIdentifierResponse>): GetPrivatePreferencesTopicIdentifierResponse {
        const message = { identifier: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPrivatePreferencesTopicIdentifierResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPrivatePreferencesTopicIdentifierResponse): GetPrivatePreferencesTopicIdentifierResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string identifier */ 1:
                    message.identifier = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPrivatePreferencesTopicIdentifierResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string identifier = 1; */
        if (message.identifier !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.identifier);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetPrivatePreferencesTopicIdentifierResponse
 */
export const GetPrivatePreferencesTopicIdentifierResponse = new GetPrivatePreferencesTopicIdentifierResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateInviteRequest$Type extends MessageType<CreateInviteRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.CreateInviteRequest", [
            { no: 1, name: "context", kind: "message", T: () => InvitationV1_Context },
            { no: 2, name: "recipient", kind: "message", T: () => SignedPublicKeyBundle },
            { no: 3, name: "created_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CreateInviteRequest>): CreateInviteRequest {
        const message = { createdNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateInviteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateInviteRequest): CreateInviteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.InvitationV1.Context context */ 1:
                    message.context = InvitationV1_Context.internalBinaryRead(reader, reader.uint32(), options, message.context);
                    break;
                case /* xmtp.message_contents.SignedPublicKeyBundle recipient */ 2:
                    message.recipient = SignedPublicKeyBundle.internalBinaryRead(reader, reader.uint32(), options, message.recipient);
                    break;
                case /* uint64 created_ns */ 3:
                    message.createdNs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateInviteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.InvitationV1.Context context = 1; */
        if (message.context)
            InvitationV1_Context.internalBinaryWrite(message.context, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_contents.SignedPublicKeyBundle recipient = 2; */
        if (message.recipient)
            SignedPublicKeyBundle.internalBinaryWrite(message.recipient, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_ns = 3; */
        if (message.createdNs !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.createdNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.CreateInviteRequest
 */
export const CreateInviteRequest = new CreateInviteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateInviteResponse$Type extends MessageType<CreateInviteResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.CreateInviteResponse", [
            { no: 1, name: "conversation", kind: "message", T: () => ConversationReference },
            { no: 2, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CreateInviteResponse>): CreateInviteResponse {
        const message = { payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateInviteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateInviteResponse): CreateInviteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.ConversationReference conversation */ 1:
                    message.conversation = ConversationReference.internalBinaryRead(reader, reader.uint32(), options, message.conversation);
                    break;
                case /* bytes payload */ 2:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateInviteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.ConversationReference conversation = 1; */
        if (message.conversation)
            ConversationReference.internalBinaryWrite(message.conversation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes payload = 2; */
        if (message.payload.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.CreateInviteResponse
 */
export const CreateInviteResponse = new CreateInviteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveInvitesRequest$Type extends MessageType<SaveInvitesRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveInvitesRequest", [
            { no: 1, name: "requests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SaveInvitesRequest_Request }
        ]);
    }
    create(value?: PartialMessage<SaveInvitesRequest>): SaveInvitesRequest {
        const message = { requests: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveInvitesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveInvitesRequest): SaveInvitesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.SaveInvitesRequest.Request requests */ 1:
                    message.requests.push(SaveInvitesRequest_Request.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveInvitesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.SaveInvitesRequest.Request requests = 1; */
        for (let i = 0; i < message.requests.length; i++)
            SaveInvitesRequest_Request.internalBinaryWrite(message.requests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveInvitesRequest
 */
export const SaveInvitesRequest = new SaveInvitesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveInvitesRequest_Request$Type extends MessageType<SaveInvitesRequest_Request> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveInvitesRequest.Request", [
            { no: 1, name: "content_topic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "timestamp_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "payload", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SaveInvitesRequest_Request>): SaveInvitesRequest_Request {
        const message = { contentTopic: "", timestampNs: 0n, payload: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveInvitesRequest_Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveInvitesRequest_Request): SaveInvitesRequest_Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string content_topic */ 1:
                    message.contentTopic = reader.string();
                    break;
                case /* uint64 timestamp_ns */ 2:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                case /* bytes payload */ 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveInvitesRequest_Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string content_topic = 1; */
        if (message.contentTopic !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contentTopic);
        /* uint64 timestamp_ns = 2; */
        if (message.timestampNs !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.timestampNs);
        /* bytes payload = 3; */
        if (message.payload.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.payload);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveInvitesRequest.Request
 */
export const SaveInvitesRequest_Request = new SaveInvitesRequest_Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveInvitesResponse$Type extends MessageType<SaveInvitesResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveInvitesResponse", [
            { no: 1, name: "responses", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SaveInvitesResponse_Response }
        ]);
    }
    create(value?: PartialMessage<SaveInvitesResponse>): SaveInvitesResponse {
        const message = { responses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveInvitesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveInvitesResponse): SaveInvitesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.SaveInvitesResponse.Response responses */ 1:
                    message.responses.push(SaveInvitesResponse_Response.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveInvitesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.SaveInvitesResponse.Response responses = 1; */
        for (let i = 0; i < message.responses.length; i++)
            SaveInvitesResponse_Response.internalBinaryWrite(message.responses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveInvitesResponse
 */
export const SaveInvitesResponse = new SaveInvitesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveInvitesResponse_Response$Type extends MessageType<SaveInvitesResponse_Response> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveInvitesResponse.Response", [
            { no: 1, name: "result", kind: "message", oneof: "response", T: () => SaveInvitesResponse_Response_Success },
            { no: 2, name: "error", kind: "message", oneof: "response", T: () => KeystoreError }
        ]);
    }
    create(value?: PartialMessage<SaveInvitesResponse_Response>): SaveInvitesResponse_Response {
        const message = { response: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveInvitesResponse_Response>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveInvitesResponse_Response): SaveInvitesResponse_Response {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success result */ 1:
                    message.response = {
                        oneofKind: "result",
                        result: SaveInvitesResponse_Response_Success.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).result)
                    };
                    break;
                case /* xmtp.keystore_api.v1.KeystoreError error */ 2:
                    message.response = {
                        oneofKind: "error",
                        error: KeystoreError.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveInvitesResponse_Response, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success result = 1; */
        if (message.response.oneofKind === "result")
            SaveInvitesResponse_Response_Success.internalBinaryWrite(message.response.result, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.keystore_api.v1.KeystoreError error = 2; */
        if (message.response.oneofKind === "error")
            KeystoreError.internalBinaryWrite(message.response.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveInvitesResponse.Response
 */
export const SaveInvitesResponse_Response = new SaveInvitesResponse_Response$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveInvitesResponse_Response_Success$Type extends MessageType<SaveInvitesResponse_Response_Success> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success", [
            { no: 1, name: "conversation", kind: "message", T: () => ConversationReference }
        ]);
    }
    create(value?: PartialMessage<SaveInvitesResponse_Response_Success>): SaveInvitesResponse_Response_Success {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveInvitesResponse_Response_Success>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveInvitesResponse_Response_Success): SaveInvitesResponse_Response_Success {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.ConversationReference conversation */ 1:
                    message.conversation = ConversationReference.internalBinaryRead(reader, reader.uint32(), options, message.conversation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveInvitesResponse_Response_Success, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.ConversationReference conversation = 1; */
        if (message.conversation)
            ConversationReference.internalBinaryWrite(message.conversation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveInvitesResponse.Response.Success
 */
export const SaveInvitesResponse_Response_Success = new SaveInvitesResponse_Response_Success$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAuthTokenRequest$Type extends MessageType<CreateAuthTokenRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.CreateAuthTokenRequest", [
            { no: 1, name: "timestamp_ns", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAuthTokenRequest>): CreateAuthTokenRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateAuthTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAuthTokenRequest): CreateAuthTokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 timestamp_ns */ 1:
                    message.timestampNs = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAuthTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 timestamp_ns = 1; */
        if (message.timestampNs !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.timestampNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.CreateAuthTokenRequest
 */
export const CreateAuthTokenRequest = new CreateAuthTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveV1ConversationsRequest$Type extends MessageType<SaveV1ConversationsRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveV1ConversationsRequest", [
            { no: 1, name: "conversations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConversationReference }
        ]);
    }
    create(value?: PartialMessage<SaveV1ConversationsRequest>): SaveV1ConversationsRequest {
        const message = { conversations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveV1ConversationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveV1ConversationsRequest): SaveV1ConversationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_contents.ConversationReference conversations */ 1:
                    message.conversations.push(ConversationReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveV1ConversationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.message_contents.ConversationReference conversations = 1; */
        for (let i = 0; i < message.conversations.length; i++)
            ConversationReference.internalBinaryWrite(message.conversations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveV1ConversationsRequest
 */
export const SaveV1ConversationsRequest = new SaveV1ConversationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveV1ConversationsResponse$Type extends MessageType<SaveV1ConversationsResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.SaveV1ConversationsResponse", []);
    }
    create(value?: PartialMessage<SaveV1ConversationsResponse>): SaveV1ConversationsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveV1ConversationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveV1ConversationsResponse): SaveV1ConversationsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SaveV1ConversationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SaveV1ConversationsResponse
 */
export const SaveV1ConversationsResponse = new SaveV1ConversationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConversationsResponse$Type extends MessageType<GetConversationsResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.GetConversationsResponse", [
            { no: 1, name: "conversations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ConversationReference }
        ]);
    }
    create(value?: PartialMessage<GetConversationsResponse>): GetConversationsResponse {
        const message = { conversations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConversationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConversationsResponse): GetConversationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.message_contents.ConversationReference conversations */ 1:
                    message.conversations.push(ConversationReference.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConversationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.message_contents.ConversationReference conversations = 1; */
        for (let i = 0; i < message.conversations.length; i++)
            ConversationReference.internalBinaryWrite(message.conversations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetConversationsResponse
 */
export const GetConversationsResponse = new GetConversationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeystoreStatusRequest$Type extends MessageType<GetKeystoreStatusRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.GetKeystoreStatusRequest", [
            { no: 1, name: "wallet_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetKeystoreStatusRequest>): GetKeystoreStatusRequest {
        const message = { walletAddress: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetKeystoreStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeystoreStatusRequest): GetKeystoreStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string wallet_address */ 1:
                    message.walletAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeystoreStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string wallet_address = 1; */
        if (message.walletAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.walletAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetKeystoreStatusRequest
 */
export const GetKeystoreStatusRequest = new GetKeystoreStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetKeystoreStatusResponse$Type extends MessageType<GetKeystoreStatusResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.GetKeystoreStatusResponse", [
            { no: 1, name: "status", kind: "enum", T: () => ["xmtp.keystore_api.v1.GetKeystoreStatusResponse.KeystoreStatus", GetKeystoreStatusResponse_KeystoreStatus, "KEYSTORE_STATUS_"] }
        ]);
    }
    create(value?: PartialMessage<GetKeystoreStatusResponse>): GetKeystoreStatusResponse {
        const message = { status: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetKeystoreStatusResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetKeystoreStatusResponse): GetKeystoreStatusResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.GetKeystoreStatusResponse.KeystoreStatus status */ 1:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetKeystoreStatusResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.GetKeystoreStatusResponse.KeystoreStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetKeystoreStatusResponse
 */
export const GetKeystoreStatusResponse = new GetKeystoreStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitKeystoreRequest$Type extends MessageType<InitKeystoreRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.InitKeystoreRequest", [
            { no: 1, name: "v1", kind: "message", oneof: "bundle", T: () => PrivateKeyBundleV1 }
        ]);
    }
    create(value?: PartialMessage<InitKeystoreRequest>): InitKeystoreRequest {
        const message = { bundle: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InitKeystoreRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitKeystoreRequest): InitKeystoreRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.PrivateKeyBundleV1 v1 */ 1:
                    message.bundle = {
                        oneofKind: "v1",
                        v1: PrivateKeyBundleV1.internalBinaryRead(reader, reader.uint32(), options, (message.bundle as any).v1)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitKeystoreRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.PrivateKeyBundleV1 v1 = 1; */
        if (message.bundle.oneofKind === "v1")
            PrivateKeyBundleV1.internalBinaryWrite(message.bundle.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.InitKeystoreRequest
 */
export const InitKeystoreRequest = new InitKeystoreRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InitKeystoreResponse$Type extends MessageType<InitKeystoreResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.InitKeystoreResponse", [
            { no: 1, name: "error", kind: "message", T: () => KeystoreError }
        ]);
    }
    create(value?: PartialMessage<InitKeystoreResponse>): InitKeystoreResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InitKeystoreResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InitKeystoreResponse): InitKeystoreResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.KeystoreError error */ 1:
                    message.error = KeystoreError.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InitKeystoreResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.KeystoreError error = 1; */
        if (message.error)
            KeystoreError.internalBinaryWrite(message.error, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.InitKeystoreResponse
 */
export const InitKeystoreResponse = new InitKeystoreResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignDigestRequest$Type extends MessageType<SignDigestRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.SignDigestRequest", [
            { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "identity_key", kind: "scalar", oneof: "signer", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "prekey_index", kind: "scalar", oneof: "signer", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SignDigestRequest>): SignDigestRequest {
        const message = { digest: new Uint8Array(0), signer: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignDigestRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignDigestRequest): SignDigestRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes digest */ 1:
                    message.digest = reader.bytes();
                    break;
                case /* bool identity_key */ 2:
                    message.signer = {
                        oneofKind: "identityKey",
                        identityKey: reader.bool()
                    };
                    break;
                case /* uint32 prekey_index */ 3:
                    message.signer = {
                        oneofKind: "prekeyIndex",
                        prekeyIndex: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignDigestRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes digest = 1; */
        if (message.digest.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.digest);
        /* bool identity_key = 2; */
        if (message.signer.oneofKind === "identityKey")
            writer.tag(2, WireType.Varint).bool(message.signer.identityKey);
        /* uint32 prekey_index = 3; */
        if (message.signer.oneofKind === "prekeyIndex")
            writer.tag(3, WireType.Varint).uint32(message.signer.prekeyIndex);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SignDigestRequest
 */
export const SignDigestRequest = new SignDigestRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRefreshJobRequest$Type extends MessageType<GetRefreshJobRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.GetRefreshJobRequest", [
            { no: 1, name: "job_type", kind: "enum", T: () => ["xmtp.keystore_api.v1.JobType", JobType, "JOB_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<GetRefreshJobRequest>): GetRefreshJobRequest {
        const message = { jobType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRefreshJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRefreshJobRequest): GetRefreshJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.JobType job_type */ 1:
                    message.jobType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRefreshJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.JobType job_type = 1; */
        if (message.jobType !== 0)
            writer.tag(1, WireType.Varint).int32(message.jobType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetRefreshJobRequest
 */
export const GetRefreshJobRequest = new GetRefreshJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRefreshJobResponse$Type extends MessageType<GetRefreshJobResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.GetRefreshJobResponse", [
            { no: 1, name: "last_run_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetRefreshJobResponse>): GetRefreshJobResponse {
        const message = { lastRunNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRefreshJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRefreshJobResponse): GetRefreshJobResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 last_run_ns */ 1:
                    message.lastRunNs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRefreshJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 last_run_ns = 1; */
        if (message.lastRunNs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.lastRunNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetRefreshJobResponse
 */
export const GetRefreshJobResponse = new GetRefreshJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRefeshJobRequest$Type extends MessageType<SetRefeshJobRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.SetRefeshJobRequest", [
            { no: 1, name: "job_type", kind: "enum", T: () => ["xmtp.keystore_api.v1.JobType", JobType, "JOB_TYPE_"] },
            { no: 2, name: "last_run_ns", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SetRefeshJobRequest>): SetRefeshJobRequest {
        const message = { jobType: 0, lastRunNs: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetRefeshJobRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRefeshJobRequest): SetRefeshJobRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.keystore_api.v1.JobType job_type */ 1:
                    message.jobType = reader.int32();
                    break;
                case /* int64 last_run_ns */ 2:
                    message.lastRunNs = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRefeshJobRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.keystore_api.v1.JobType job_type = 1; */
        if (message.jobType !== 0)
            writer.tag(1, WireType.Varint).int32(message.jobType);
        /* int64 last_run_ns = 2; */
        if (message.lastRunNs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.lastRunNs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SetRefeshJobRequest
 */
export const SetRefeshJobRequest = new SetRefeshJobRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRefreshJobResponse$Type extends MessageType<SetRefreshJobResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.SetRefreshJobResponse", []);
    }
    create(value?: PartialMessage<SetRefreshJobResponse>): SetRefreshJobResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetRefreshJobResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRefreshJobResponse): SetRefreshJobResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetRefreshJobResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.SetRefreshJobResponse
 */
export const SetRefreshJobResponse = new SetRefreshJobResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopicMap$Type extends MessageType<TopicMap> {
    constructor() {
        super("xmtp.keystore_api.v1.TopicMap", [
            { no: 1, name: "topics", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => TopicMap_TopicData } }
        ]);
    }
    create(value?: PartialMessage<TopicMap>): TopicMap {
        const message = { topics: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TopicMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopicMap): TopicMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, xmtp.keystore_api.v1.TopicMap.TopicData> topics */ 1:
                    this.binaryReadMap1(message.topics, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TopicMap["topics"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TopicMap["topics"] | undefined, val: TopicMap["topics"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = TopicMap_TopicData.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field xmtp.keystore_api.v1.TopicMap.topics");
            }
        }
        map[key ?? ""] = val ?? TopicMap_TopicData.create();
    }
    internalBinaryWrite(message: TopicMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, xmtp.keystore_api.v1.TopicMap.TopicData> topics = 1; */
        for (let k of Object.keys(message.topics)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            TopicMap_TopicData.internalBinaryWrite(message.topics[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.TopicMap
 */
export const TopicMap = new TopicMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TopicMap_TopicData$Type extends MessageType<TopicMap_TopicData> {
    constructor() {
        super("xmtp.keystore_api.v1.TopicMap.TopicData", [
            { no: 1, name: "created_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "peer_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "invitation", kind: "message", T: () => InvitationV1 }
        ]);
    }
    create(value?: PartialMessage<TopicMap_TopicData>): TopicMap_TopicData {
        const message = { createdNs: 0n, peerAddress: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TopicMap_TopicData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TopicMap_TopicData): TopicMap_TopicData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 created_ns */ 1:
                    message.createdNs = reader.uint64().toBigInt();
                    break;
                case /* string peer_address */ 2:
                    message.peerAddress = reader.string();
                    break;
                case /* xmtp.message_contents.InvitationV1 invitation */ 3:
                    message.invitation = InvitationV1.internalBinaryRead(reader, reader.uint32(), options, message.invitation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TopicMap_TopicData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 created_ns = 1; */
        if (message.createdNs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.createdNs);
        /* string peer_address = 2; */
        if (message.peerAddress !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.peerAddress);
        /* xmtp.message_contents.InvitationV1 invitation = 3; */
        if (message.invitation)
            InvitationV1.internalBinaryWrite(message.invitation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.TopicMap.TopicData
 */
export const TopicMap_TopicData = new TopicMap_TopicData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConversationHmacKeysRequest$Type extends MessageType<GetConversationHmacKeysRequest> {
    constructor() {
        super("xmtp.keystore_api.v1.GetConversationHmacKeysRequest", [
            { no: 1, name: "topics", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetConversationHmacKeysRequest>): GetConversationHmacKeysRequest {
        const message = { topics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConversationHmacKeysRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConversationHmacKeysRequest): GetConversationHmacKeysRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string topics */ 1:
                    message.topics.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConversationHmacKeysRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string topics = 1; */
        for (let i = 0; i < message.topics.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.topics[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysRequest
 */
export const GetConversationHmacKeysRequest = new GetConversationHmacKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConversationHmacKeysResponse$Type extends MessageType<GetConversationHmacKeysResponse> {
    constructor() {
        super("xmtp.keystore_api.v1.GetConversationHmacKeysResponse", [
            { no: 1, name: "hmac_keys", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => GetConversationHmacKeysResponse_HmacKeys } }
        ]);
    }
    create(value?: PartialMessage<GetConversationHmacKeysResponse>): GetConversationHmacKeysResponse {
        const message = { hmacKeys: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConversationHmacKeysResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConversationHmacKeysResponse): GetConversationHmacKeysResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys> hmac_keys */ 1:
                    this.binaryReadMap1(message.hmacKeys, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetConversationHmacKeysResponse["hmacKeys"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetConversationHmacKeysResponse["hmacKeys"] | undefined, val: GetConversationHmacKeysResponse["hmacKeys"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = GetConversationHmacKeysResponse_HmacKeys.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field xmtp.keystore_api.v1.GetConversationHmacKeysResponse.hmac_keys");
            }
        }
        map[key ?? ""] = val ?? GetConversationHmacKeysResponse_HmacKeys.create();
    }
    internalBinaryWrite(message: GetConversationHmacKeysResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys> hmac_keys = 1; */
        for (let k of Object.keys(message.hmacKeys)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            GetConversationHmacKeysResponse_HmacKeys.internalBinaryWrite(message.hmacKeys[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysResponse
 */
export const GetConversationHmacKeysResponse = new GetConversationHmacKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConversationHmacKeysResponse_HmacKeyData$Type extends MessageType<GetConversationHmacKeysResponse_HmacKeyData> {
    constructor() {
        super("xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData", [
            { no: 1, name: "thirty_day_periods_since_epoch", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "hmac_key", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetConversationHmacKeysResponse_HmacKeyData>): GetConversationHmacKeysResponse_HmacKeyData {
        const message = { thirtyDayPeriodsSinceEpoch: 0, hmacKey: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConversationHmacKeysResponse_HmacKeyData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConversationHmacKeysResponse_HmacKeyData): GetConversationHmacKeysResponse_HmacKeyData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 thirty_day_periods_since_epoch */ 1:
                    message.thirtyDayPeriodsSinceEpoch = reader.int32();
                    break;
                case /* bytes hmac_key */ 2:
                    message.hmacKey = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConversationHmacKeysResponse_HmacKeyData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 thirty_day_periods_since_epoch = 1; */
        if (message.thirtyDayPeriodsSinceEpoch !== 0)
            writer.tag(1, WireType.Varint).int32(message.thirtyDayPeriodsSinceEpoch);
        /* bytes hmac_key = 2; */
        if (message.hmacKey.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.hmacKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData
 */
export const GetConversationHmacKeysResponse_HmacKeyData = new GetConversationHmacKeysResponse_HmacKeyData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetConversationHmacKeysResponse_HmacKeys$Type extends MessageType<GetConversationHmacKeysResponse_HmacKeys> {
    constructor() {
        super("xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => GetConversationHmacKeysResponse_HmacKeyData }
        ]);
    }
    create(value?: PartialMessage<GetConversationHmacKeysResponse_HmacKeys>): GetConversationHmacKeysResponse_HmacKeys {
        const message = { values: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetConversationHmacKeysResponse_HmacKeys>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetConversationHmacKeysResponse_HmacKeys): GetConversationHmacKeysResponse_HmacKeys {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData values */ 1:
                    message.values.push(GetConversationHmacKeysResponse_HmacKeyData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetConversationHmacKeysResponse_HmacKeys, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeyData values = 1; */
        for (let i = 0; i < message.values.length; i++)
            GetConversationHmacKeysResponse_HmacKeyData.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.keystore_api.v1.GetConversationHmacKeysResponse.HmacKeys
 */
export const GetConversationHmacKeysResponse_HmacKeys = new GetConversationHmacKeysResponse_HmacKeys$Type();
