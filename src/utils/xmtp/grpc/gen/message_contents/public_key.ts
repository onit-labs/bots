// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "message_contents/public_key.proto" (package "xmtp.message_contents", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Signature } from "./signature";
/**
 * UnsignedPublicKey represents a generalized public key,
 * defined as a union to support cryptographic algorithm agility.
 *
 * @generated from protobuf message xmtp.message_contents.UnsignedPublicKey
 */
export interface UnsignedPublicKey {
    /**
     * @generated from protobuf field: uint64 created_ns = 1;
     */
    createdNs: bigint;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "secp256K1Uncompressed";
        /**
         * @generated from protobuf field: xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed secp256k1_uncompressed = 3 [json_name = "secp256k1Uncompressed"];
         */
        secp256K1Uncompressed: UnsignedPublicKey_Secp256k1Uncompressed;
    } | {
        oneofKind: undefined;
    };
}
// Supported key types

/**
 * EC: SECP256k1
 *
 * @generated from protobuf message xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed
 */
export interface UnsignedPublicKey_Secp256k1Uncompressed {
    /**
     * uncompressed point with prefix (0x04) [ P || X || Y ], 65 bytes
     *
     * @generated from protobuf field: bytes bytes = 1;
     */
    bytes: Uint8Array;
}
/**
 * SignedPublicKey
 *
 * @generated from protobuf message xmtp.message_contents.SignedPublicKey
 */
export interface SignedPublicKey {
    /**
     * @generated from protobuf field: bytes key_bytes = 1;
     */
    keyBytes: Uint8Array; // embeds an UnsignedPublicKey
    /**
     * @generated from protobuf field: xmtp.message_contents.Signature signature = 2;
     */
    signature?: Signature; // signs key_bytes
}
/**
 * PublicKeyBundle packages the cryptographic keys associated with a wallet.
 *
 * @generated from protobuf message xmtp.message_contents.SignedPublicKeyBundle
 */
export interface SignedPublicKeyBundle {
    /**
     * Identity key MUST be signed by the wallet.
     *
     * @generated from protobuf field: xmtp.message_contents.SignedPublicKey identity_key = 1;
     */
    identityKey?: SignedPublicKey;
    /**
     * Pre-key MUST be signed by the identity key.
     *
     * @generated from protobuf field: xmtp.message_contents.SignedPublicKey pre_key = 2;
     */
    preKey?: SignedPublicKey;
}
// LEGACY

/**
 * PublicKey represents a generalized public key,
 * defined as a union to support cryptographic algorithm agility.
 *
 * @generated from protobuf message xmtp.message_contents.PublicKey
 */
export interface PublicKey {
    /**
     * @generated from protobuf field: uint64 timestamp = 1;
     */
    timestamp: bigint;
    /**
     * @generated from protobuf field: optional xmtp.message_contents.Signature signature = 2;
     */
    signature?: Signature;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "secp256K1Uncompressed";
        /**
         * @generated from protobuf field: xmtp.message_contents.PublicKey.Secp256k1Uncompressed secp256k1_uncompressed = 3 [json_name = "secp256k1Uncompressed"];
         */
        secp256K1Uncompressed: PublicKey_Secp256k1Uncompressed;
    } | {
        oneofKind: undefined;
    };
}
/**
 * The key bytes
 *
 * @generated from protobuf message xmtp.message_contents.PublicKey.Secp256k1Uncompressed
 */
export interface PublicKey_Secp256k1Uncompressed {
    /**
     * uncompressed point with prefix (0x04) [ P || X || Y ], 65 bytes
     *
     * @generated from protobuf field: bytes bytes = 1;
     */
    bytes: Uint8Array;
}
/**
 * PublicKeyBundle packages the cryptographic keys associated with a wallet,
 * both senders and recipients are identified by their key bundles.
 *
 * @generated from protobuf message xmtp.message_contents.PublicKeyBundle
 */
export interface PublicKeyBundle {
    /**
     * Identity key MUST be signed by the wallet.
     *
     * @generated from protobuf field: xmtp.message_contents.PublicKey identity_key = 1;
     */
    identityKey?: PublicKey;
    /**
     * Pre-key MUST be signed by the identity key.
     *
     * @generated from protobuf field: xmtp.message_contents.PublicKey pre_key = 2;
     */
    preKey?: PublicKey;
}
// @generated message type with reflection information, may provide speed optimized methods
class UnsignedPublicKey$Type extends MessageType<UnsignedPublicKey> {
    constructor() {
        super("xmtp.message_contents.UnsignedPublicKey", [
            { no: 1, name: "created_ns", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "secp256k1_uncompressed", kind: "message", jsonName: "secp256k1Uncompressed", oneof: "union", T: () => UnsignedPublicKey_Secp256k1Uncompressed }
        ]);
    }
    create(value?: PartialMessage<UnsignedPublicKey>): UnsignedPublicKey {
        const message = { createdNs: 0n, union: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnsignedPublicKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnsignedPublicKey): UnsignedPublicKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 created_ns */ 1:
                    message.createdNs = reader.uint64().toBigInt();
                    break;
                case /* xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed secp256k1_uncompressed = 3 [json_name = "secp256k1Uncompressed"];*/ 3:
                    message.union = {
                        oneofKind: "secp256K1Uncompressed",
                        secp256K1Uncompressed: UnsignedPublicKey_Secp256k1Uncompressed.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).secp256K1Uncompressed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnsignedPublicKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 created_ns = 1; */
        if (message.createdNs !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.createdNs);
        /* xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed secp256k1_uncompressed = 3 [json_name = "secp256k1Uncompressed"]; */
        if (message.union.oneofKind === "secp256K1Uncompressed")
            UnsignedPublicKey_Secp256k1Uncompressed.internalBinaryWrite(message.union.secp256K1Uncompressed, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.UnsignedPublicKey
 */
export const UnsignedPublicKey = new UnsignedPublicKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnsignedPublicKey_Secp256k1Uncompressed$Type extends MessageType<UnsignedPublicKey_Secp256k1Uncompressed> {
    constructor() {
        super("xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed", [
            { no: 1, name: "bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UnsignedPublicKey_Secp256k1Uncompressed>): UnsignedPublicKey_Secp256k1Uncompressed {
        const message = { bytes: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnsignedPublicKey_Secp256k1Uncompressed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnsignedPublicKey_Secp256k1Uncompressed): UnsignedPublicKey_Secp256k1Uncompressed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes bytes */ 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnsignedPublicKey_Secp256k1Uncompressed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes bytes = 1; */
        if (message.bytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.bytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.UnsignedPublicKey.Secp256k1Uncompressed
 */
export const UnsignedPublicKey_Secp256k1Uncompressed = new UnsignedPublicKey_Secp256k1Uncompressed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignedPublicKey$Type extends MessageType<SignedPublicKey> {
    constructor() {
        super("xmtp.message_contents.SignedPublicKey", [
            { no: 1, name: "key_bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "signature", kind: "message", T: () => Signature }
        ]);
    }
    create(value?: PartialMessage<SignedPublicKey>): SignedPublicKey {
        const message = { keyBytes: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignedPublicKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignedPublicKey): SignedPublicKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes key_bytes */ 1:
                    message.keyBytes = reader.bytes();
                    break;
                case /* xmtp.message_contents.Signature signature */ 2:
                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignedPublicKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes key_bytes = 1; */
        if (message.keyBytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keyBytes);
        /* xmtp.message_contents.Signature signature = 2; */
        if (message.signature)
            Signature.internalBinaryWrite(message.signature, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.SignedPublicKey
 */
export const SignedPublicKey = new SignedPublicKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignedPublicKeyBundle$Type extends MessageType<SignedPublicKeyBundle> {
    constructor() {
        super("xmtp.message_contents.SignedPublicKeyBundle", [
            { no: 1, name: "identity_key", kind: "message", T: () => SignedPublicKey },
            { no: 2, name: "pre_key", kind: "message", T: () => SignedPublicKey }
        ]);
    }
    create(value?: PartialMessage<SignedPublicKeyBundle>): SignedPublicKeyBundle {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SignedPublicKeyBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignedPublicKeyBundle): SignedPublicKeyBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.SignedPublicKey identity_key */ 1:
                    message.identityKey = SignedPublicKey.internalBinaryRead(reader, reader.uint32(), options, message.identityKey);
                    break;
                case /* xmtp.message_contents.SignedPublicKey pre_key */ 2:
                    message.preKey = SignedPublicKey.internalBinaryRead(reader, reader.uint32(), options, message.preKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignedPublicKeyBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.SignedPublicKey identity_key = 1; */
        if (message.identityKey)
            SignedPublicKey.internalBinaryWrite(message.identityKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_contents.SignedPublicKey pre_key = 2; */
        if (message.preKey)
            SignedPublicKey.internalBinaryWrite(message.preKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.SignedPublicKeyBundle
 */
export const SignedPublicKeyBundle = new SignedPublicKeyBundle$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKey$Type extends MessageType<PublicKey> {
    constructor() {
        super("xmtp.message_contents.PublicKey", [
            { no: 1, name: "timestamp", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "signature", kind: "message", T: () => Signature },
            { no: 3, name: "secp256k1_uncompressed", kind: "message", jsonName: "secp256k1Uncompressed", oneof: "union", T: () => PublicKey_Secp256k1Uncompressed }
        ]);
    }
    create(value?: PartialMessage<PublicKey>): PublicKey {
        const message = { timestamp: 0n, union: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PublicKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKey): PublicKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 timestamp */ 1:
                    message.timestamp = reader.uint64().toBigInt();
                    break;
                case /* optional xmtp.message_contents.Signature signature */ 2:
                    message.signature = Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
                    break;
                case /* xmtp.message_contents.PublicKey.Secp256k1Uncompressed secp256k1_uncompressed = 3 [json_name = "secp256k1Uncompressed"];*/ 3:
                    message.union = {
                        oneofKind: "secp256K1Uncompressed",
                        secp256K1Uncompressed: PublicKey_Secp256k1Uncompressed.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).secp256K1Uncompressed)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 timestamp = 1; */
        if (message.timestamp !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.timestamp);
        /* optional xmtp.message_contents.Signature signature = 2; */
        if (message.signature)
            Signature.internalBinaryWrite(message.signature, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_contents.PublicKey.Secp256k1Uncompressed secp256k1_uncompressed = 3 [json_name = "secp256k1Uncompressed"]; */
        if (message.union.oneofKind === "secp256K1Uncompressed")
            PublicKey_Secp256k1Uncompressed.internalBinaryWrite(message.union.secp256K1Uncompressed, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.PublicKey
 */
export const PublicKey = new PublicKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKey_Secp256k1Uncompressed$Type extends MessageType<PublicKey_Secp256k1Uncompressed> {
    constructor() {
        super("xmtp.message_contents.PublicKey.Secp256k1Uncompressed", [
            { no: 1, name: "bytes", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PublicKey_Secp256k1Uncompressed>): PublicKey_Secp256k1Uncompressed {
        const message = { bytes: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PublicKey_Secp256k1Uncompressed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKey_Secp256k1Uncompressed): PublicKey_Secp256k1Uncompressed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes bytes */ 1:
                    message.bytes = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKey_Secp256k1Uncompressed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes bytes = 1; */
        if (message.bytes.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.bytes);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.PublicKey.Secp256k1Uncompressed
 */
export const PublicKey_Secp256k1Uncompressed = new PublicKey_Secp256k1Uncompressed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKeyBundle$Type extends MessageType<PublicKeyBundle> {
    constructor() {
        super("xmtp.message_contents.PublicKeyBundle", [
            { no: 1, name: "identity_key", kind: "message", T: () => PublicKey },
            { no: 2, name: "pre_key", kind: "message", T: () => PublicKey }
        ]);
    }
    create(value?: PartialMessage<PublicKeyBundle>): PublicKeyBundle {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PublicKeyBundle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKeyBundle): PublicKeyBundle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xmtp.message_contents.PublicKey identity_key */ 1:
                    message.identityKey = PublicKey.internalBinaryRead(reader, reader.uint32(), options, message.identityKey);
                    break;
                case /* xmtp.message_contents.PublicKey pre_key */ 2:
                    message.preKey = PublicKey.internalBinaryRead(reader, reader.uint32(), options, message.preKey);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKeyBundle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xmtp.message_contents.PublicKey identity_key = 1; */
        if (message.identityKey)
            PublicKey.internalBinaryWrite(message.identityKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* xmtp.message_contents.PublicKey pre_key = 2; */
        if (message.preKey)
            PublicKey.internalBinaryWrite(message.preKey, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xmtp.message_contents.PublicKeyBundle
 */
export const PublicKeyBundle = new PublicKeyBundle$Type();
